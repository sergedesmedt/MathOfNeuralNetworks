<!DOCTYPE html>
<!--



-->
<!--
to research
===========
* slider binding
-->

<html>
<head>
	<title>KnockoutJS / D3 Slider Testing ground</title>
	<script type="text/javascript" async
			src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async>
	</script>
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>

	<style>
		svg {
			font: 10px sans-serif;
			shape-rendering: geometricPrecision;
		}

		rect {
			fill: #fff;
		}

		.vectorline {
			stroke: #000000;
			fill: #000000;
		}

		.vectorp1x {
			stroke: #808080;
			fill: #000000;
		}

		.vectorp2x {
			stroke: #808080;
			fill: #000000;
		}

		.vectorendpoint {
			stroke: #000000;
			fill: #ff0000;
		}

		.vectorstartpoint {
			stroke: #000000;
			fill: #ff0000;
		}

		.axis path,
		.axis line {
			fill: none;
			stroke: #d7d7d7;
		}
	</style>

</head>
<body>

	<!--<input type="range" data-bind="sliderBinding: sliderA, testMe: 'hi'">-->

	<input type="text" data-bind="value: rangeValue" />
	<input type="range" min="10" max="50" data-bind="value: rangeValue, valueUpdate: 'input'" />

	<p>First String: <input data-bind="value: p1x" /></p>
	<p>Second String: <input data-bind="value: p1y" /></p>

	<div id="viz"></div>

	<script type="text/javascript">

		// https://knockoutjs.com/documentation/custom-bindings.html
		// https://github.com/cosminstefanxp/bootstrap-slider-knockout-binding/blob/master/bootstrap-slider-knockout-binding.js
		// https://stackoverflow.com/questions/32825264/knockout-js-bind-slider-range-input

		//ko.bindingHandlers.sliderBinding = {
		//	init: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
		//		// This will be called when the binding is first applied to an element
		//		// Set up any initial state, event handlers, etc. here

		//		console.log("sliderBinding.init");
		//	},
		//	update: function (element, valueAccessor, allBindings, viewModel, bindingContext) {
		//		// This will be called once when the binding is first applied to an element,
		//		// and again whenever any observables/computeds that are accessed change
		//		// Update the DOM element based on the supplied values here.

		//		console.log("sliderBinding.update");
		//	}
		//};






		var updateFunc = function UpdateVector() {

			var vectors = svg.selectAll(".vector")
				.data(vm.allVectors);

			vectors.select(".vectorstartpoint")
				//.attr("class", "vectorendpoint")
				//.style("stroke", "black")  // colour the line
				.attr("cx", function (d) { return x(d.p1.x()); })
				.attr("cy", function (d) { return y(d.p1.y()); })
				//.attr("r", "8px")
				//.attr("fill", "red")
				;

			vectors.select(".vectorendpoint")
				//.attr("class", "vectorendpoint")
				//.style("stroke", "black")  // colour the line
				.attr("cx", function (d) { return x(d.p2.x()); })
				.attr("cy", function (d) { return y(d.p2.y()); })
				//.attr("r", "8px")
				//.attr("fill", "red")
				;

			vectors.select(".vectorline")
				//.attr("class", "vectorline")
				//.style("stroke", "black")  // colour the line
				.attr("x1", function (d) { return x(d.p1.x()); })
				.attr("y1", function (d) { return y(d.p1.y()); })
				.attr("x2", function (d) { return x(d.p2.x()); })
				.attr("y2", function (d) { return y(d.p2.y()); })
				//.attr("marker-end", "url(#arrow)")
				;

			vectors.select(".vectorarc")
				//.attr("class", "vectorarc")
				.attr("d", function (d) { return vectorAngle(d); })
				//.attr("stroke", "blue")
				//.attr("stroke-width", 1)
				//.attr("fill", "none")
				//.attr("marker-end", "url(#arrow)")
				;

		}

		function MyViewModel() {
			this.p0x = ko.observable(20)/*.extend({ number: true })*/;
			this.p0y = ko.observable(20)/*.extend({ number: true })*/;

			this.v1dx = ko.observable(-20);
			this.v1dy = ko.observable(30);

			this.p1x = ko.computed(function () { return Number(this.p0x()) + Number(this.v1dx()); }, this);
			this.p1y = ko.computed(function () { return Number(this.p0y()) + Number(this.v1dy()); }, this);
			//this.p1x = ko.observable(10)/*.extend({ number: true })*/;
			//this.p1y = ko.observable(30)/*.extend({ number: true })*/;


			this.p0x.subscribe(function (newValue) { updateFunc(); });
			this.p0y.subscribe(function (newValue) { updateFunc(); });
			this.p1x.subscribe(function (newValue) { updateFunc(); });
			this.p1y.subscribe(function (newValue) { updateFunc(); });

			this.rangeValue = ko.observable(30);


			vector1 = {
				tp: "defp1delta",
				p1: { x: this.p0x, y: this.p0y },
				delta: { x: this.v1dx, y: this.v1dy },
				p2: { x: this.p1x, y: this.p1y }
			};

			this.allVectors = [vector1];

		}

		var vm = new MyViewModel();




		var margin = { top: 40, right: 40, bottom: 40, left: 40 },
			width = 200,
			height = 200;
		var x = d3.scaleLinear()
			.domain([0, width / 2])
			.range([0, width]);
		var y = d3.scaleLinear()
			.domain([0, height / 2])
			.range([height, 0]);
		var xAxis = d3.axisBottom()
			.scale(x)
			.ticks(10)
			.tickSize(-height);
		var yAxis = d3.axisLeft()
			.scale(y)
			.ticks(10)
			.tickSize(-width);
		var svg = d3.select("#viz").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom);

		svg.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
		svg.append("rect")
			.attr("width", width)
			.attr("height", height);
		svg.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis);
		svg.append("g")
			.attr("class", "y axis")
			.call(yAxis);

		//v1 = {
		//	p1: { x: 0, y: 0 }, p2: { x: 10, y: 40 }
		//};
		//v2 = {
		//	p1: { x: 0, y: 0 }, p2: { x: 40, y: 55 }
		//};
		//v3 = {
		//	p1: { x: 10, y: 20 }, p2: { x: 50, y: 70 }
		//};

		//vs = [v1, v2, v3];
		//vs = [v1];

		svg.append("svg:defs").append("marker")
			.attr("class", "vectorline")
			.attr("id", "linearrow")
			.attr("refX", 10)
			.attr("refY", 3)
			.attr("markerWidth", 20)
			.attr("markerHeight", 20)
			.attr("markerUnits", "userSpaceOnUse")
			.attr("orient", "auto")
			.append("path")
			.attr("d", "M 0 0 10 3 0 6")
			//.style("fill", "black")
			;

		svg.append("svg:defs").append("marker")
			.attr("class", "vectorline")
			.attr("id", "circlearrow")
			.attr("refX", 10)
			.attr("refY", 3)
			.attr("markerWidth", 30)
			.attr("markerHeight", 30)
			.attr("markerUnits", "userSpaceOnUse")
			.attr("orient", "auto")
			.append("path")
			.attr("d", "M 0 0 10 3 0 6")
			//.style("fill", "black")
			;

		data = svg.selectAll(".vector")
			.data(vm.allVectors).enter()

		g = data
			.append("g")
			.attr("class", "vector");

		g.append("circle")
			.attr("class", function (d) { return (d.tp == "defp1p2") ? "vectorendpoint defp1p2" : "vectorendpoint defp1delta"; })
			//.style("stroke", "black")  // colour the line
			.attr("cx", function (d) { return x(d.p2.x()); })
			.attr("cy", function (d) { return y(d.p2.y()); })
			.attr("r", "8px")
			//.attr("fill", "red")
			;

		//g.append("circle")
		//	.attr("class", "vectorstartpoint")
		//	//.style("stroke", "black")  // colour the line
		//	.attr("cx", function (d) { return x(d.p1.x()); })
		//	.attr("cy", function (d) { return y(d.p1.y()); })
		//	.attr("r", "8px")
		//	//.attr("fill", "red")
		;

		g.append("line")          // attach a line
			.attr("class", function (d) { return (d.tp == "defp1p2") ? "vectorline" : "vectorline defp1delta"; })
			//.attr("class", "vectorline defp1delta")
			//.style("stroke", "black")  // colour the line
			.attr("x1", function (d) { return x(d.p1.x()); })
			.attr("y1", function (d) { return y(d.p1.y()); })
			.attr("x2", function (d) { return x(d.p2.x()); })
			.attr("y2", function (d) { return y(d.p2.y()); })
			.attr("marker-end", "url(#linearrow)")
			;



		// https://www.dashingd3js.com/svg-paths-and-d3js
		// https://stackoverflow.com/questions/45120229/how-to-draw-arc-with-d3-js-with-only-outer-radius-or-sector-of-circle
		// https://www.tutorialspoint.com/d3js/d3js_paths_api.htm

		var lineData = [{ "x": 1, "y": 5 }, { "x": 20, "y": 20 },
		{ "x": 40, "y": 10 }, { "x": 60, "y": 40 },
		{ "x": 80, "y": 5 }, { "x": 100, "y": 60 }];

		var lineFunction = d3.line()
			.x(function (d) { return d.x; })
			.y(function (d) { return d.y; })
			.curve(d3.curveLinear);

		//var arc = d3.arc()
		//	.innerRadius(50)
		//	.outerRadius(50)
		//	.startAngle(-Math.PI / 2)
		//	.endAngle(170 * Math.PI / 180)

		function getAngle(dx, dy) {
			//return d3.quarterPi;

			console.log("getAngle: dx = " + dx + ", dy = " + dy);

			var cosx = dx / Math.sqrt(dx * dx + dy * dy);
			var cosy = dy / Math.sqrt(dx * dx + dy * dy);

			var multiplyer = 1;
			if (cosy < 0)
				multiplyer = -1;

			console.log("getAngle: cosx = " + cosx + ", cosy = " + cosy);

			return multiplyer * Math.acos(cosx)
		}

		function vectorAngle(d) {
			var varc = d3.path();
			////arc1.moveTo(100, 100);
			////arc1.lineTo(50, 50);
			varc.arc(x(d.p1.x()), y(d.p1.y()), 25, 0, getAngle(x(d.p2.x()) - x(d.p1.x()), y(d.p2.y()) - y(d.p1.y())), 1);

			return varc
		}

		//var arc1 = d3.path();
		//////arc1.moveTo(100, 100);
		//////arc1.lineTo(50, 50);
		//arc1.arc(100, 100, 25, 0, getAngle(x(60) - x(50), y(80) - y(50)), 1);

		//Draws a circular arc segment with the specified center ⟨x, y⟩, radius, startAngle and endAngle.If anticlockwise is true,
		//the arc is drawn in the anticlockwise direction; otherwise, it is drawn in the clockwise direction.
		//If the current point is not equal to the starting point of the arc, a straight line is drawn from the current point
		//to the start of the arc

		//var arc2 = d3.path();
		//arc2.moveTo(0, 200);
		////arc1.lineTo(50, 50);
		//arc2.arcTo(50, 100, -50, -50, 50);

		//Draws a circular arc segment with the specified radius that starts tangent to the line between the current point
		//and the specified point ⟨x1, y1⟩ and ends tangent to the line between the specified points ⟨x1, y1⟩ and ⟨x2, y2⟩.
		//If the first tangent point is not equal to the current point, a straight line is drawn between the current point
		//and the first tangent point

		g.append("path")
			.attr("class", "vectorarc")
			.attr("d", function (d) { return vectorAngle(d); })
			.attr("stroke", "blue")
			.attr("stroke-width", 1)
			.attr("fill", "none")
			.attr("marker-end", "url(#circlearrow)")
			;

		//g.append("circle")
		//	.attr("class", "arcmarker")
		//	//.style("stroke", "black")  // colour the line
		//	.attr("cx", 0)
		//	.attr("cy", 200)
		//	.attr("r", "8px")

		//g.append("circle")
		//	.attr("class", "arcmarker")
		//	//.style("stroke", "black")  // colour the line
		//	.attr("cx", 50)
		//	.attr("cy", 100)
		//	.attr("r", "8px")

		//g.append("circle")
		//	.attr("class", "arcmarker")
		//	//.style("stroke", "black")  // colour the line
		//	.attr("cx", 50)
		//	.attr("cy", 100)
		//	.attr("r", "8px")

		//g.append("line")
		//	.attr("class", "vectorp1x")
		//	.attr("x1", function (d) { return x(d.p1.x); })
		//	.attr("y1", y(-10))
		//	.attr("x2", function (d) { return x(d.p1.x); })
		//	.attr("y2", function (d) { return y(d.p1.y); })
		//	;

		//g.append("line")
		//	.attr("class", "vectorp2x")
		//	.attr("x1", function (d) { return x(d.p2.x); })
		//	.attr("y1", y(-10))
		//	.attr("x2", function (d) { return x(d.p2.x); })
		//	.attr("y2", function (d) { return y(d.p2.y); })
		//	;

		//g.append("text")
		//	.attr("class", "vectorvaluedx")
		//	.style("text-anchor", "middle")
		//	.text(function (d) { return (d.p2.x - d.p1.x); })
		//	.attr("x", function (d) { return x(d.p1.x + (d.p2.x - d.p1.x) / 2); })
		//	.attr("y", y(-10))
		//	;


		//let dragp1 = d3.drag()
		//	.on('start', dragstarted)
		//	.on('drag', draggedp1)
		//	.on('end', dragended);

		let defp1delta_dragp2 = d3.drag()
			.on('start', dragstarted)
			.on('drag', defp1delta_draggedp2)
			.on('end', dragended);

		let defp1p2_dragp2 = d3.drag()
			.on('start', dragstarted)
			.on('drag', defp1p2_draggedp2)
			.on('end', dragended);

		//svg.selectAll('.vectorstartpoint')
		//	.call(dragp1);

		svg.selectAll('.vectorendpoint.defp1delta')
			.call(defp1delta_dragp2);

		svg.selectAll('.vectorendpoint.defp1p2')
			.call(defp1p2_dragp2);

		function dragstarted(d) {
			//d3.select(this).raise().classed('active', true);
		}

		function draggedp1(d) {
			console.log("draggedp1");
			//console.log(this);
			//console.log(d);

			d.p1.x(x.invert(d3.event.x));
			d.p1.y(y.invert(d3.event.y));

			d3.select(this)
				.attr('cx', x(d.p1.x()))
				.attr('cy', y(d.p1.y()))
			//focus.select('path').attr('d', line);
			//console.log(d3.select(this.parentNode)
			//	.select('.vectorline'));

			d3.select(this.parentNode)
				.select('.vectorline')
				.attr("x1", x(d.p1.x()))
				.attr("y1", y(d.p1.y()))

			//d3.select(this.parentNode)
			//	.select('.vectorp1x')
			//	.attr("x1", x(d.p1.x))
			//	.attr("y1", y(-10))
			//	.attr("x2", x(d.p1.x))
			//	.attr("y2", y(d.p1.y))

			//d3.select(this.parentNode)
			//	.select('.vectorvaluedx')
			//	.text((d.p2.x - d.p1.x))
			//	.attr("x", x(d.p1.x + (d.p2.x - d.p1.x) / 2))
			//	.attr("y", y(-10))

		}

		function defp1delta_draggedp2(d) {
			console.log("defp1delta_draggedp2");
			//console.log(this);
			//console.log(d);

			var newX = x.invert(d3.event.x);
			var newY = y.invert(d3.event.y);

			d.delta.x(newX - Number(d.p1.x()));
			d.delta.y(newY - Number(d.p1.y()));

			//d.p2.x(x.invert(d3.event.x));
			//d.p2.y(y.invert(d3.event.y));

			d3.select(this)
				.attr('cx', x(d.p2.x()))
				.attr('cy', y(d.p2.y()))
			//focus.select('path').attr('d', line);
			//console.log(d3.select(this.parentNode)
			//	.select('.vectorline'));

			d3.select(this.parentNode)
				.select('.vectorline')
				.attr("x2", x(d.p2.x()))
				.attr("y2", y(d.p2.y()))

			//d3.select(this.parentNode)
			//	.select('.vectorp2x')
			//	.attr("x1", x(d.p2.x))
			//	.attr("y1", y(-10))
			//	.attr("x2", x(d.p2.x))
			//	.attr("y2", y(d.p2.y))

			//d3.select(this.parentNode)
			//	.select('.vectorvaluedx')
			//	.text((d.p2.x - d.p1.x))
			//	.attr("x", x(d.p1.x + (d.p2.x - d.p1.x) / 2))
			//	.attr("y", y(-10))

		}

		function defp1p2_draggedp2(d) {
			console.log("defp1delta_draggedp2");
			//console.log(this);
			//console.log(d);

			//var newX = x.invert(d3.event.x);
			//var newY = y.invert(d3.event.y);

			//d.delta.x(newX - Number(d.p1.x()));
			//d.delta.y(newY - Number(d.p1.y()));

			d.p2.x(x.invert(d3.event.x));
			d.p2.y(y.invert(d3.event.y));

			d3.select(this)
				.attr('cx', x(d.p2.x()))
				.attr('cy', y(d.p2.y()))
			//focus.select('path').attr('d', line);
			//console.log(d3.select(this.parentNode)
			//	.select('.vectorline'));

			d3.select(this.parentNode)
				.select('.vectorline')
				.attr("x2", x(d.p2.x()))
				.attr("y2", y(d.p2.y()))

			//d3.select(this.parentNode)
			//	.select('.vectorp2x')
			//	.attr("x1", x(d.p2.x))
			//	.attr("y1", y(-10))
			//	.attr("x2", x(d.p2.x))
			//	.attr("y2", y(d.p2.y))

			//d3.select(this.parentNode)
			//	.select('.vectorvaluedx')
			//	.text((d.p2.x - d.p1.x))
			//	.attr("x", x(d.p1.x + (d.p2.x - d.p1.x) / 2))
			//	.attr("y", y(-10))

		}

		function dragended(d) {
			//d3.select(this).classed('active', false);
		}

		// Activates knockout.js
		ko.applyBindings(vm);
	</script>

</body>
</html>
