<!DOCTYPE html>
<html>
<head>
	<title>Learn Perceptron learning</title>
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>
	<script type="text/javascript" src="./d3-selection-multi/d3-selection-multi.js"></script>
	<script type="text/javascript" src="./js/space2dim.js"></script>
	<script type="text/javascript" src="./js/point.js"></script>
	<script type="text/javascript" src="./js/rico.js"></script>
	<script type="text/javascript" src="./js/circle.js"></script>
	<script type="text/javascript" src="./js/vector.js"></script>
	<script type="text/javascript" src="./js/line.js"></script>
	<script type="text/javascript" src="./js/perceptron.js"></script>
	<script type="text/javascript" src="./js/perceptronresult.js"></script>
	<script type="text/javascript" src="./js/perceptronlearningpoint.js"></script>

	<link rel="stylesheet" type="text/css" href="./css/space2dim.css">
	<link rel="stylesheet" type="text/css" href="./css/vector.css">
	<link rel="stylesheet" type="text/css" href="./css/line.css">
	<link rel="stylesheet" type="text/css" href="./css/perceptron.css">
	<link rel="stylesheet" type="text/css" href="./css/perceptronresult.css">
	<link rel="stylesheet" type="text/css" href="./css/perceptronlearningpoint.css">

	<style>
		.vectorline.defp1delta.ricotomovevector {
			stroke: #ff6a00;
			stroke-width: 1;
			fill: #ff6a00;
		}
		.vectorarrow.defp1delta.ricotomovevector {
			stroke: #ff6a00;
			stroke-width: 1;
			fill: #ff6a00;
		}
	</style>
</head>
<body>
	<div id="perceptronlearninganimation"></div>
	<div id="perceptronandlearning"></div>
	<div id="perceptronorlearning"></div>
	<div id="perceptronlearning"></div>
	<div id="perceptronlearningnormalized"></div>

	<script type="text/javascript">

		function createPerceptronLearningAnimationSample() {
			var space2dimpercep = new Space2Dim("perceptronlearninganimation", 200, 200, -2, 2, -2, 2);

			function ViewModel() {
				this.p0x = ko.observable(0);
				this.p0y = ko.observable(0);

				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				//var cGenerator = d3.randomUniform(-50, 50);
				var c = 0; //cGenerator();

				var anorm = a / Math.sqrt(a * a + b * b);
				var bnorm = b / Math.sqrt(a * a + b * b);

				this.perc1a = ko.observable(anorm);
				this.perc1b = ko.observable(bnorm);
				this.perc1c = ko.observable(c);

				console.log("a[" + anorm + "], b[" + b + "], c[" + c + "]");

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});


				var p0 = new Point2Dim(this.p0x, this.p0y);
				var p1 = new Point2Dim(
					ko.computed(function () { return this.perc1a() /* * -1 * this.perc1c()*/; }, this),
					ko.computed(function () { return this.perc1b() /* * -1 * this.perc1c()*/; }, this)
				);

				var prico = new Vector2Dim(
					{ p1: p0, p2: p1, delta: p1 },
					{ name: "p", cssclass: "perceprico", p1draggable: 0, p2draggable: 0 }
				);

				this.circlesToShow = [];
				this.vectorsToShow = [prico];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});


				// var fadeVectorIntoExistance = function FadeVectorIntoExistance(space2dim, line, v, xt, yt) {
				// 	console.log("FadeVectorIntoExistance x[" + xt + "], y[" + yt + "]");

				// 	line
				// 		.style("opacity", 0)
				// 		.transition()
				// 		.duration(1500)
				// 		.style("opacity", 1)
				// 		;
				// }

				//var moveVectorByP1ToPositionAnimated = function MoveVectorByP1ToPositionAnimated(space2dim, line, v, xt, yt) {
				//	console.log("MoveVectorByP1ToPositionAnimated x[" + xt + "], y[" + yt + "]");

				//	var vx1 = v._p1.getX();
				//	var vy1 = v._p1.getY();

				//	var dxt = xt - vx1;
				//	var dyt = yt - vy1;

				//	console.log("delta x[" + dxt + "], y[" + dyt + "]");

				//	var xs = space2dim.convertXToCanvas(xt);
				//	var ys = space2dim.convertYToCanvas(yt);

				//	if (v._deftype == "defp1delta") {
				//		var vx2t = vx1 + v._delta.getX() + dxt;
				//		var vy2t = vy1 + v._delta.getY() + dyt;

				//		var xe = space2dim.convertXToCanvas(vx2t);
				//		var ye = space2dim.convertYToCanvas(vy2t);

				//		console.log("will animate to point start(x[" + xs + "], y[" + ys + "]) - end(x[" + xe + "], y[" + ye +"])");

				//		line.transition()
				//			.duration(1500)
				//			.attrs({
				//				x1: xs,
				//				y1: ys,
				//				x2: xe,
				//				y2: ye
				//			})
				//			.on("end", function () {
				//				console.log("line transition ended");

				//				v._p1.setX(xt);
				//				v._p1.setY(yt);

				//				//updateFunc();
				//			});

				//	}
				//	else if (v._deftype == "defp1p2") {
				//		console.log("unsupported");
				//	}
				//	else {
				//		console.log("don't know what to do");
				//	}
				//}


				var me = this;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					//console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");



					let desiredclass = 1;
					if (shiftKey)
						desiredclass = 0;

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);
					me.allPerceptronLearnings.push(perceptronLearningPoint);

					let currentclass = perceptron1.CalcPerceptronOutcome(x, y);

					let error = 0;
					if (currentclass != desiredclass) {
						error = desiredclass - currentclass;
					}

					console.log("LearnFromData currentclass(" + currentclass + ") ? desiredclass(" + desiredclass + ")");

					if (error == 0) {
						return;
					}


					var clickedPoint = space2dimpercep.CreatePoint(x, y);

					var vlearn = new Vector2Dim(
						{ p1: p0, p2: clickedPoint },
						{ name: "", cssclass: "learnvector", p1draggable: 0, p2draggable: 0 }
					);
					me.vectorsToShow.push(vlearn);

					var pricoStartPoint = space2dimpercep.CreatePoint(prico._p1.getX(), prico._p1.getY());
					var pricoEndPoint = space2dimpercep.CreatePoint(prico._p2.getX(), prico._p2.getY());

					var vricoToMove = new Vector2Dim(
						{ p1: pricoStartPoint, p2: pricoEndPoint, delta: pricoEndPoint },
						{ name: "", cssclass: "ricotomovevector", p1draggable: 0, p2draggable: 0 }
					);
					me.vectorsToShow.push(vricoToMove);

					space2dimpercep.update();

					var svg = space2dimpercep.getSvg();

					svg.selectAll(".vectorline.learnvector")
						.style("opacity", 0)
					svg.selectAll(".vectorline.defp1delta.ricotomovevector")
						.style("opacity", 0)

					var fadeInLearnVectorTransition = svg
						.transition().duration(1500);

					fadeInLearnVectorTransition.selectAll(".vectorline.learnvector")
						.style("opacity", 1);
						

					var fadeInPerceptronRicoTransition = fadeInLearnVectorTransition
						.transition().duration(1500);
						
					fadeInPerceptronRicoTransition.selectAll(".vectorline.defp1delta.ricotomovevector")
						.style("opacity", 1);


					var vx1 = vricoToMove._p1.getX();
					var vy1 = vricoToMove._p1.getY();

					var dxt = x - vx1;
					var dyt = y - vy1;

					console.log("delta x[" + dxt + "], y[" + dyt + "]");

					var xs = space2dimpercep.convertXToCanvas(x);
					var ys = space2dimpercep.convertYToCanvas(y);

					var vx2t = vx1 + vricoToMove._delta.getX() + dxt;
					var vy2t = vy1 + vricoToMove._delta.getY() + dyt;

					var xe = space2dimpercep.convertXToCanvas(vx2t);
					var ye = space2dimpercep.convertYToCanvas(vy2t);

					console.log("will animate to point start(x[" + xs + "], y[" + ys + "]) - end(x[" + xe + "], y[" + ye +"])");				

					var moveTransition = fadeInPerceptronRicoTransition
						.transition().duration(1500);

					moveTransition.select(".vectorline.defp1delta.ricotomovevector")
						.attrs({
							x1: xs,
							y1: ys,
							x2: xe,
							y2: ye
						})
						.on("end", function () {
							console.log("moveTransition ended");

							vricoToMove._p1.setX(x);
							vricoToMove._p1.setY(y);
							vricoToMove._p2.setX(vx2t);
							vricoToMove._p2.setY(vy2t);

							//updateFunc();
						});


					learnTransition = moveTransition
						.transition().duration(1500);

					var newWeights = {
						a: perceptron1._a(),
						b: perceptron1._b(),
						c: perceptron1._c()
					};

					var initialWeights = {
						a: perceptron1._a(),
						b: perceptron1._b(),
						c: perceptron1._c()
					};

					learnTransition.tween("learnTween", function () {
						var interpolate = d3.interpolate(0, 1);
						return function (t) {
							//console.log("justSomeTween: " + t)

							var newWeights = {
								a: (initialWeights.a + (t * (error) * x)),
								b: (initialWeights.b + (t * (error) * y)),
								c: initialWeights.c
							};
							perceptron1.SetWeightVector(newWeights);
						};
					});


					var fadeOutLearnVectorTransition = learnTransition
						.transition().duration(1500);

					fadeOutLearnVectorTransition.selectAll(".vectorline.learnvector")
						.style("opacity", 0);
						
					fadeOutLearnVectorTransition
						.on("end", function () {
							console.log("last transition ended");

							me.vectorsToShow.pop(vlearn);
							me.vectorsToShow.pop(vricoToMove);

							space2dimpercep.update();
						});						

					var fadeOutPerceptronRicoTransition = fadeOutLearnVectorTransition
						.transition().duration(1500);
						
					fadeOutPerceptronRicoTransition.selectAll(".vectorline.defp1delta.ricotomovevector")
						.style("opacity", 0);

				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronANDLearningSample() {
			var space2dimpercep = new Space2Dim("perceptronandlearning", 200, 200, -2, 2, -2, 2);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-1, 1);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				var step = -1;

				var truthTable = [
					{ x: 0, y: 0, outcome: 0 },
					{ x: 1, y: 0, outcome: 0 },
					{ x: 0, y: 1, outcome: 0 },
					{ x: 1, y: 1, outcome: 1 }
				];
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					//console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					step++;
					if (step >= 4)
						step = 0;

					console.log("will learn datapoint for step=" + step);
					console.log("Step1 outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
					console.log("Step1 outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
					console.log("Step1 outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
					console.log("Step1 outcome x[" + 1 + "], y[" + 1 + "], desired[" + 1 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 1) + "]");

					console.log("will learn datapoint x=" + truthTable[step].x + ", y=" + truthTable[step].y + ", desired outcome:" + truthTable[step].outcome);

					let newWeights = perceptron1.LearnFromData(truthTable[step].x, truthTable[step].y, truthTable[step].outcome);
					perceptron1.SetWeightVector(newWeights);

					console.log("Final outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
					console.log("Final outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
					console.log("Final outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
					console.log("Final outcome x[" + 1 + "], y[" + 1 + "], desired[" + 1 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 1) + "]");

					me.allPerceptronLearnings.removeAll();

					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 0, y: 0, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 1, y: 0, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 0, y: 1, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 1, y: 1, desiredclass: 1, perceptron: perceptron1 },
						{}
					));
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronORLearningSample() {
			var space2dimpercep = new Space2Dim("perceptronorlearning", 200, 200, -2, 2, -2, 2);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-1, 1);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				var step = -1;

				var truthTable = [
					{ x: 0, y: 0, outcome: 0 },
					{ x: 1, y: 0, outcome: 1 },
					{ x: 0, y: 1, outcome: 1 },
					{ x: 1, y: 1, outcome: 1 }
				];
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					//console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					step++;
					if (step >= 4)
						step = 0;

					console.log("will learn datapoint for step=" + step);
					console.log("Step1 outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
					console.log("Step1 outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
					console.log("Step1 outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
					console.log("Step1 outcome x[" + 1 + "], y[" + 1 + "], desired[" + 1 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 1) + "]");

					console.log("will learn datapoint x=" + truthTable[step].x + ", y=" + truthTable[step].y + ", desired outcome:" + truthTable[step].outcome);

					let newWeights = perceptron1.LearnFromData(truthTable[step].x, truthTable[step].y, truthTable[step].outcome);
					perceptron1.SetWeightVector(newWeights);

					console.log("Final outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
					console.log("Final outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
					console.log("Final outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
					console.log("Final outcome x[" + 1 + "], y[" + 1 + "], desired[" + 1 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 1) + "]");

					me.allPerceptronLearnings.removeAll();

					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 0, y: 0, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 1, y: 0, desiredclass: 1, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 0, y: 1, desiredclass: 1, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 1, y: 1, desiredclass: 1, perceptron: perceptron1 },
						{}
					));
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronLearningSample() {
			var space2dimpercep = new Space2Dim("perceptronlearning", 200, 200, -5, 5, -5, 5);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-50, 50);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				var step = 0;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					// https://slideplayer.com/slide/5226142/

					let desiredclass = 1;
					if (shiftKey)
						desiredclass = 0;

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					perceptron1.SetWeightVector(newWeights);

					me.allPerceptronLearnings.push(perceptronLearningPoint);
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronLearningNormalizedSample() {
			var space2dimpercep = new Space2Dim("perceptronlearningnormalized", 200, 200, -1, 1, -1, 1);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-1, 1);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					let desiredclass = 1;
					if (shiftKey)
						desiredclass = 0;

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					perceptron1.SetWeightVector(newWeights);

					me.allPerceptronLearnings.push(perceptronLearningPoint);
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}

		createPerceptronLearningAnimationSample();
		//createPerceptronANDLearningSample();
		//createPerceptronORLearningSample();
		//createPerceptronLearningSample();
		//createPerceptronLearningNormalizedSample()

	</script>

</body>
</html >
