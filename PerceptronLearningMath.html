<!DOCTYPE html>
<html>
<head>
	<title>Learn Perceptron learning</title>
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>
	<script type="text/javascript" src="./d3-selection-multi/d3-selection-multi.js"></script>
	<script type="text/javascript" src="./js/space2dim.js"></script>
	<script type="text/javascript" src="./js/point.js"></script>
	<script type="text/javascript" src="./js/rico.js"></script>
	<script type="text/javascript" src="./js/circle.js"></script>
	<script type="text/javascript" src="./js/vector.js"></script>
	<script type="text/javascript" src="./js/line.js"></script>
	<script type="text/javascript" src="./js/perceptron.js"></script>
	<script type="text/javascript" src="./js/perceptronresult.js"></script>
	<script type="text/javascript" src="./js/perceptronlearningpoint.js"></script>

	<link rel="stylesheet" type="text/css" href="./css/space2dim.css">
	<link rel="stylesheet" type="text/css" href="./css/vector.css">
	<link rel="stylesheet" type="text/css" href="./css/line.css">
	<link rel="stylesheet" type="text/css" href="./css/perceptron.css">
	<link rel="stylesheet" type="text/css" href="./css/perceptronresult.css">
	<link rel="stylesheet" type="text/css" href="./css/perceptronlearningpoint.css">

	<style>
	</style>
</head>
<body>
	<div id="perceptronlearninganimation"></div>
	<div id="perceptronandlearning"></div>
	<div id="perceptronorlearning"></div>
	<div id="perceptronlearning"></div>
	<div id="perceptronlearningnormalized"></div>

	<script type="text/javascript">

		function createPerceptronLearningAnimationSample() {
			var space2dimpercep = new Space2Dim("perceptronlearninganimation", 200, 200, -75, 75, -75, 75);

			function ViewModel() {
				this.p0x = ko.observable(0);
				this.p0y = ko.observable(0);

				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-50, 50);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});


				var p0 = new Point2Dim(this.p0x, this.p0y);
				var p1 = new Point2Dim(this.perc1a, this.perc1b);

				var prico = new Vector2Dim(
					{ p1: p0, p2: p1 },
					{ name: "p", dvaluelvl: 1, p1draggable: 0, p2draggable: 1 }
				);

				this.circlesToShow = [];
				this.vectorsToShow = [prico];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					//console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					let desiredclass = 1;
					if (shiftKey)
						desiredclass = 0;

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					perceptron1.SetWeightVector(newWeights);

					me.allPerceptronLearnings.push(perceptronLearningPoint);
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronANDLearningSample() {
			var space2dimpercep = new Space2Dim("perceptronandlearning", 200, 200, -2, 2, -2, 2);

			function ViewModel() {
				//var abGenerator = d3.randomUniform(-1, 1);
				var a = -1.1; //abGenerator();
				var b = -1.1; //abGenerator();
				//var cGenerator = d3.randomUniform(-50, 50);
				var c = 2.9; //cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				var step = 0;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					//console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					let desiredclass = 1;

					step++;

					//if (step == 1) {
					//	// a = 0.6, b = 0.2, c = -1.9
					//	console.log("Step1 outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
					//	console.log("Step1 outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
					//	console.log("Step1 outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
					//	x = 1;
					//	y = 1; // => 0.6, 0.2, -0.9
					//	desiredclass = 1;
					//	currentclass = perceptron1.CalcPerceptronOutcome(x, y);
					//	console.log("Step1 outcome x[" + x + "], y[" + y + "], desired[" + desiredclass + "], current[" + currentclass + "]");
					//}

					if (step == 1) {
						// a = 0.6, b = 0.2, c = -0.9
						console.log("Step1 outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
						console.log("Step1 outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
						console.log("Step1 outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
						console.log("Step1 outcome x[" + 1 + "], y[" + 1 + "], desired[" + 1 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 1) + "]");
						x = 0;
						y = 0; // => 1.6, 1.2, 0.1
						desiredclass = 0;
						//currentclass = perceptron1.CalcPerceptronOutcome(x, y);
					}

					//if (step == 2) {
					//	x = 1;
					//	y = 0; // => -0.9, 0.6, 2.2
					//	desiredclass = 0;
					//}

					//if (step == 3) {
					//	x = 0;
					//	y = 1; // => -1.9, 1.6, 1.2
					//	desiredclass = 0;
					//}

					//if (step == 4) {
					//	x = 0;
					//	y = 0; // => -1.9, 1.6, 1.2
					//	desiredclass = 0;
					//}

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					
					//let newWeights = {a: 1.6, b:1.2, c:-1.7};
					perceptron1.SetWeightVector(newWeights);

					console.log("Final outcome x[" + 0 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 0) + "]");
					console.log("Final outcome x[" + 1 + "], y[" + 0 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 0) + "]");
					console.log("Final outcome x[" + 0 + "], y[" + 1 + "], desired[" + 0 + "], current[" + perceptron1.CalcPerceptronOutcome(0, 1) + "]");
					console.log("Final outcome x[" + 1 + "], y[" + 1 + "], desired[" + 1 + "], current[" + perceptron1.CalcPerceptronOutcome(1, 1) + "]");

					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 0, y: 0, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 1, y: 0, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 0, y: 1, desiredclass: 0, perceptron: perceptron1 },
						{}
					));
					me.allPerceptronLearnings.push(new PerceptronLearningPoint(
						{ x: 1, y: 1, desiredclass: 1, perceptron: perceptron1 },
						{}
					));
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronORLearningSample() {
			var space2dimpercep = new Space2Dim("perceptronorlearning", 200, 200, -5, 5, -5, 5);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = 0.6; //abGenerator();
				var b = 0.2; //abGenerator();
				var cGenerator = d3.randomUniform(-50, 50);
				var c = -0.9; //cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				var step = 0;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					// https://slideplayer.com/slide/5226142/

					let desiredclass = 1;
					//if (shiftKey)
					//	desiredclass = 0;

					step++;

					if (step == 1) {
						x = 1;
						y = 1; // => 0.1, 1.6, 1.2
						desiredclass = 1;
					}

					if (step == 2) {
						x = 1;
						y = -1; // => -0.9, 0.6, 2.2
						desiredclass = 1;
					}

					if (step == 3) {
						x = -1;
						y = 1; // => -1.9, 1.6, 1.2
						desiredclass = 1;
					}

					if (step == 4) {
						x = -1;
						y = -1; // => -1.9, 1.6, 1.2
						desiredclass = 0;
					}

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					perceptron1.SetWeightVector(newWeights);

					me.allPerceptronLearnings.push(perceptronLearningPoint);
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronLearningSample() {
			var space2dimpercep = new Space2Dim("perceptronlearning", 200, 200, -5, 5, -5, 5);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-50, 50);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				var step = 0;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					// https://slideplayer.com/slide/5226142/

					let desiredclass = 1;
					if (shiftKey)
						desiredclass = 0;

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					perceptron1.SetWeightVector(newWeights);

					me.allPerceptronLearnings.push(perceptronLearningPoint);
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}


		function createPerceptronLearningNormalizedSample() {
			var space2dimpercep = new Space2Dim("perceptronlearningnormalized", 200, 200, -1, 1, -1, 1);

			function ViewModel() {
				var abGenerator = d3.randomUniform(-1, 1);
				var a = abGenerator();
				var b = abGenerator();
				var cGenerator = d3.randomUniform(-1, 1);
				var c = cGenerator();
				console.log("a[" + a + "], b[" + b + "], c[" + c + "]");

				this.perc1a = ko.observable(a);
				this.perc1b = ko.observable(b);
				this.perc1c = ko.observable(c);

				this.perc1a.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1b.subscribe(function (newValue) { space2dimpercep.update(); });
				this.perc1c.subscribe(function (newValue) { space2dimpercep.update(); });

				var perceptron1 = new Perceptron(
					{ a: this.perc1a, b: this.perc1b, c: this.perc1c },
					{});

				this.circlesToShow = [];
				this.vectorsToShow = [];
				this.raysToShow = [];
				this.perceptronsToShow = [perceptron1];
				this.allPerceptronLearnings = ko.observableArray([]);
				this.allPerceptronLearnings.subscribe(function (newValue) {
					//console.log("allPerceptronResults.subscribe");
					space2dimpercep.update();
				});

				var me = this;
				space2dimpercep.OnClick(function (x, y, shiftKey) {
					console.log("space2dim clicked at [" + x + "," + y + "], shiftKey[" + shiftKey + "]");

					let desiredclass = 1;
					if (shiftKey)
						desiredclass = 0;

					let perceptronLearningPoint = new PerceptronLearningPoint(
						{ x: x, y: y, desiredclass: desiredclass, perceptron: perceptron1 },
						{}
					);

					let newWeights = perceptron1.LearnFromData(x, y, desiredclass);
					perceptron1.SetWeightVector(newWeights);

					me.allPerceptronLearnings.push(perceptronLearningPoint);
				});

			}

			var vm = new ViewModel();

			space2dimpercep.appenGlobalAttributes(Vector2Dim.global);
			space2dimpercep.appenGlobalAttributes(PerceptronResult.global);
			space2dimpercep.registerHandler(Perceptron.draw, Perceptron.update, function () { return vm.perceptronsToShow; });
			space2dimpercep.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vm.raysToShow; });
			space2dimpercep.registerHandler(Circle.draw, Circle.update, function () { return vm.circlesToShow; });
			space2dimpercep.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vm.vectorsToShow; });
			space2dimpercep.registerHandler(PerceptronLearningPoint.draw, PerceptronLearningPoint.update, function () { return vm.allPerceptronLearnings(); });
			space2dimpercep.show();

			ko.applyBindings(vm);

			return vm;
		}

		//createPerceptronLearningAnimationSample();
		createPerceptronANDLearningSample();
		//createPerceptronORLearningSample();
		//createPerceptronLearningSample();
		//createPerceptronLearningNormalizedSample()

	</script>

</body>
</html >
