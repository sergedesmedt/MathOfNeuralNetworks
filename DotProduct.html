<!DOCTYPE html>
<html>
<head>
	<title>Learn Dot product</title>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
		showProcessingMessages: false,
		tex2jax: { inlineMath: [['$','$'],['\\(','\\)']] }
		});
	</script>
	<!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-debug.js"></script>
	<script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
	<script type="text/javascript" src="https://d3js.org/d3-selection-multi.v1.min.js"></script>-->
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>
	<script type="text/javascript" src="./d3-selection-multi/d3-selection-multi.js"></script>
	<script type="text/javascript" src="./mathjax-2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
	<script type="text/javascript" src="./js/mathexpressions.js"></script>
	<script type="text/javascript" src="./js/space2dim.js"></script>
	<script type="text/javascript" src="./js/point.js"></script>
	<script type="text/javascript" src="./js/vector.js"></script>
	<script type="text/javascript" src="./js/vectorangle.js"></script>

	<link rel="stylesheet" type="text/css" href="./css/article.css">
	<link rel="stylesheet" type="text/css" href="./css/space2dim.css">
	<link rel="stylesheet" type="text/css" href="./css/vector.css">
	<link rel="stylesheet" type="text/css" href="./css/vectorangle.css">

	<style>
		.vectorline.projectionaonb {
			stroke: #ff6a00;
			stroke-width: 1;
			fill: #ff6a00;
		}

		.vectorarrow.projectionaonb {
			stroke: #ff6a00;
			stroke-width: 1;
			fill: #ff6a00;
		}

		.vectorline.projectionbona {
			stroke: #0094ff;
			stroke-width: 1;
			fill: #0094ff;
		}

		.vectorarrow.projectionbona {
			stroke: #0094ff;
			stroke-width: 1;
			fill: #0094ff;
		}

		.vectorline.projline {
			stroke: #aaaaaa;
			stroke-width: 1;
			fill: #aaaaaa;
		}
	</style>
</head>
<body>
	<div>
		<h1 id="learn_dotproduct">Dotproduct of two vectors</h1>
		<p>Two vectors in 2-dimensional space:</p>
		<p>
			$$ \begin{aligned}
			\mathbf{a} &= (a_1, a_2), \text{ in }\mathbb{R}^2\\
			\mathbf{b} &= (b_1, b_2), \text{ in }\mathbb{R}^2
			\end{aligned}$$
		</p>
		<p>The dot-product is the scalar (a real number) resulting of taking the sum of the products of the corresponding components of the two vectors:</p>
		<p>
			$$ \begin{aligned}
			c &= \mathbf{a} \cdot \mathbf{b}\\
			&= a_1 b_1 + a_2 b_2\\
			&= {\lvert\lvert{a}\lvert\lvert}\text{ }{\lvert\lvert{b}\lvert\lvert}\text{ }cos(\alpha)\\
			\end{aligned}$$
		</p>
		<div>
			<div>
				<p>A sample:</p>
				<label><input name="dotprod_visutype" type="radio" value="sumofprod" data-bind="checked: DotProd.showRule"/>Show sum of products</label><br />
				<label><input name="dotprod_visutype" type="radio" value="cosprod" data-bind="checked: DotProd.showRule" />Show cosine rule</label>
			</div>
			<div class="sample_container_height100">
				<div id="dotproduct_sample">
					$${}$$
				</div>
			</div>
		</div>
	</div>
	<div style="width:100%">
			<div>You can drag the two red dots to change the vectors $a$ and $b$ and see how this affects the result of the dot product</div>
			<div id="dotproduct" class="divcentered"></div>
	</div>
	<div>
		<h1 id="learn_dotproduct_commutative">The Dotproduct of two vectors is commutative</h1>
		<p>Two vectors in 2-dimensional space:</p>
		<p>
			$$ \begin{aligned}
			\mathbf{a} &= (a_1, a_2), \text{ in }\mathbb{R}^2\\
			\mathbf{b} &= (b_1, b_2), \text{ in }\mathbb{R}^2
			\end{aligned}$$
		</p>
		<p>The dot-product is commutative:</p>
		<p>
			$$ \begin{aligned}
			c &= \mathbf{a} \cdot \mathbf{b}\\
			&= a_1 b_1 + a_2 b_2\\
			&= b_1 a_1 + b_2 a_2\\
			&= \mathbf{b} \cdot \mathbf{a}\\
			\end{aligned}$$
		</p>
		<div>
			<div>
				<p>A sample:</p>
			</div>
			<div class="sample_container_height100">
				<div id="dotproductcommutativity_sample">
					$${}$$
				</div>
			</div>
		</div>
	</div>
	<div style="width:100%">
		<div id="dotproductcommutativity" class="divcentered"></div>
	</div>
	<div>
		<h1 id="learn_dotproduct_distributive">The Dotproduct is distributive</h1>
		<p>Three vectors in 2-dimensional space:</p>
		<p>
			$$ \begin{aligned}
			\mathbf{a} &= (a_1, a_2), \text{ in }\mathbb{R}^2\\
			\mathbf{b} &= (b_1, b_2), \text{ in }\mathbb{R}^2\\
			\mathbf{c} &= (c_1, c_2), \text{ in }\mathbb{R}^2
			\end{aligned}$$
		</p>
		<p>The dot-product is distributive:</p>
		<p>
			$$ \begin{aligned}
			d &= \mathbf{a} \cdot (\mathbf{b}+\mathbf{c})\\
			&= a_1 (b_1 + c_1) + a_2 (b_2 + c_2)\\
			&= a_1 b_1 + a_1 c_1 + a_2 b_2 + a_2 c_2\\
			&= a_1 b_1 + a_2 b_2 + a_1 c_1 + a_2 c_2\\
			&= \mathbf{a} \cdot \mathbf{b} + \mathbf{a} \cdot \mathbf{c}\\
			\end{aligned}$$
		</p>
		<p>A sample:</p>
		<div class="sample_container_height100">
			<div id="dotproductdistributive_sample">
				$${}$$
			</div>
		</div>
	</div>
	<div style="width:100%">
		<div id="dotproductdistributivity" class="divcentered"></div>
	</div>

	<script type="text/javascript">

		function projectVectorOnVector(vToProj, vOn) {
			this.p2onv1x = ko.computed(function () {
				// vOn as a unit vector
				let uv1x = (vOn._p2.getX() - vOn._p1.getX()) / vOn.getSize();
				let uv1y = (vOn._p2.getY() - vOn._p1.getY()) / vOn.getSize();

				let angle = vToProj.getAngleToX() - vOn.getAngleToX();

				// components of vToProj along this unit vector
				let dv2x = vToProj.getSize() * Math.cos(angle) * uv1x;

				return dv2x;
			});
			this.p2onv1y = ko.computed(function () {
				// vOn as a unit vector
				let uv1x = (vOn._p2.getX() - vOn._p1.getX()) / vOn.getSize();
				let uv1y = (vOn._p2.getY() - vOn._p1.getY()) / vOn.getSize();

				let angle = vToProj.getAngleToX() - vOn.getAngleToX();

				// components of vToProj along this unit vector
				let dv2y = vToProj.getSize() * Math.cos(angle) * uv1y;

				return dv2y;
			});

			let p1onv2 = new Point2Dim({x: this.p2onv1x, y: this.p2onv1y}, {});
			return p1onv2;
		}

		function createDotProductSample() {
			let magnitudeMathExpression = new MathExpressions();
			let space2dimvsum = new Space2Dim("dotproduct", 400, 400, -100, 100, -100, 100);

			function DotProductViewModel() {
				let me = this;

				this.showRule = ko.observable("sumofprod");

				this.p0x = ko.observable(0);
				this.p0y = ko.observable(0);

				this.a1 = ko.observable(40);
				this.a2 = ko.observable(30);

				this.b1 = ko.observable(10);
				this.b2 = ko.observable(50);


				let p0 = new Point2Dim({x: this.p0x, y: this.p0y}, {});
				let pa = new Point2Dim({x: this.a1, y: this.a2}, {});
				let pb = new Point2Dim({x: this.b1, y: this.b2}, {});

				let a = new Vector2Dim(
					{ p1: p0, p2: pa },
					{ name: "a", dvaluelvl: 1, /*showSize: 1,*/ p1draggable: 0, p2draggable: 1 }
				);

				let b = new Vector2Dim(
					{ p1: p0, p2: pb },
					{ name: "b", dvaluelvl: 1, /*showSize: 1,*/ p1draggable: 0, p2draggable: 1 }
				);


				// calculate the projection of p1 on vector 2
				this.paonbx = ko.computed(function () {
					// vector b as a unit vector
					let ub1 = (b._p2.getX() - b._p1.getX()) / b.getSize();
					let ub2 = (b._p2.getY() - b._p1.getY()) / b.getSize();

					let angle = b.getAngleToX() - a.getAngleToX();

					// components of a along this unit vector
					let da1 = a.getSize() * Math.cos(angle) * ub1;

					return da1;
				});
				this.paonby = ko.computed(function () {
					// vector b as a unit vector
					let ub1 = (b._p2.getX() - b._p1.getX()) / b.getSize();
					let ub2 = (b._p2.getY() - b._p1.getY()) / b.getSize();

					let angle = b.getAngleToX() - a.getAngleToX();

					// components of vector a along this unit vector
					let da2 = a.getSize() * Math.cos(angle) * ub2;

					return da2;
				});

				let paonb = new Point2Dim({x: this.paonbx, y: this.paonby}, {});

				let aonb = new Vector2Dim(
					{ p1: p0, p2: paonb },
					{ name: "aonb", showSize: 1, p1draggable: 0, p2draggable: 0, cssclass: "projectionv1onv2" }
				)
				let aonbprojl = new Vector2Dim(
					{ p1: pa, p2: paonb },
					{ showEndArrow: 0, p1draggable: 0, p2draggable: 0, cssclass: "projline" }
				)



				let angle1 = new VectorAngle2Dim(
					{ vs: a, ve: b },
					{ showAngle: 1 }
				);

				let getMathExpression = function () {
					let a1Formatted = d3.format(".2f")(pa.getX());
					let a2Formatted = d3.format(".2f")(pa.getY());
					let b1Formatted = d3.format(".2f")(pb.getX());
					let b2Formatted = d3.format(".2f")(pb.getY());

					let aLengthFormatted = d3.format(".2f")(a.getSize());
					let bLengthFormatted = d3.format(".2f")(b.getSize());

					let angleFormatted = d3.format(".2f")(angle1.getAngle());

					let dotProductFormatted = d3.format(".2f")(Vector2Dim.dotProduct(a, b));

					let mathExpression = "\\begin{aligned}"
						+ "c &= \\mathbf{a} \\cdot \\mathbf{b}\\\\"
						+ ((me.showRule() == "sumofprod") ? ("&= " + a1Formatted + " * " + b1Formatted + " + " + a2Formatted + " * " + b2Formatted + "\\\\") : "")
						+ ((me.showRule() == "cosprod") ? ("&= " + aLengthFormatted + " * " + bLengthFormatted + " * cos(" + angleFormatted + ") \\\\") : "")
						+ "&= " + dotProductFormatted
						+ "\\end{aligned}";

					return mathExpression;
				}

				magnitudeMathExpression.RegisterExpression("dotproduct_sample", getMathExpression);

				this.vectorsToShow = [a, b];
				this.anglesToShow = [];

				this.showRule.subscribe(function (newValue) {
					if (me.showRule() == "sumofprod") {
						me.vectorsToShow.pop(aonb);
						me.vectorsToShow.pop(aonbprojl);
						me.anglesToShow.pop(angle1);

						a.setConfig({ dvaluelvl: 1, showSize: 0});
						b.setConfig({ dvaluelvl: 1, showSize: 0 });
					}
					else {
						me.vectorsToShow.push(aonb);
						me.vectorsToShow.push(aonbprojl);
						me.anglesToShow.push(angle1);

						a.setConfig({ dvaluelvl: 0, showSize: 1 });
						b.setConfig({ dvaluelvl: 0, showSize: 1 });
					}
					space2dimvsum.update();
					magnitudeMathExpression.QueueUpdate();
				});
				this.p0x.subscribe(function (newValue) { space2dimvsum.update(); });
				this.p0y.subscribe(function (newValue) { space2dimvsum.update(); });
				this.a1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.a2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.b1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.b2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });

			}

			let vdp = new DotProductViewModel();

			space2dimvsum.appenGlobalAttributes(Vector2Dim.global);
			space2dimvsum.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vdp.vectorsToShow; });
			space2dimvsum.registerHandler(VectorAngle2Dim.draw, VectorAngle2Dim.update, function () { return vdp.anglesToShow; });
			space2dimvsum.show();

			return vdp;
		}

		function createDotProductCommutativitySample() {
			let magnitudeMathExpression = new MathExpressions();
			let space2dimvsum = new Space2Dim("dotproductcommutativity", 400, 400, -100, 100, -100, 100);

			function DotProductCommutativityViewModel() {
				this.p0x = ko.observable(0);
				this.p0y = ko.observable(0);

				this.a1 = ko.observable(40);
				this.a2 = ko.observable(30);

				this.b1 = ko.observable(10);
				this.b2 = ko.observable(50);


				let p0 = new Point2Dim({x: this.p0x, y: this.p0y}, {});
				let pa = new Point2Dim({x: this.a1, y: this.a2}, {});
				let pb = new Point2Dim({x: this.b1, y: this.b2}, {});

				let a = new Vector2Dim(
					{ p1: p0, p2: pa },
					{ name: "a", dvaluelvl: 1, showSize: 0, p1draggable: 0, p2draggable: 1 }
				);

				let b = new Vector2Dim(
					{ p1: p0, p2: pb },
					{ name: "b", dvaluelvl: 1, showSize: 0, p1draggable: 0, p2draggable: 1 }
				);


				// calculate the projection of pa on b
				this.paonbx = ko.computed(function () {
					// b as a unit vector
					let ub1 = (b._p2.getX() - b._p1.getX()) / b.getSize();
					let ub2 = (b._p2.getY() - b._p1.getY()) / b.getSize();

					let angle = b.getAngleToX() - a.getAngleToX();

					// components of a along this unit vector
					let da1 = a.getSize() * Math.cos(angle) * ub1;

					return da1;
				});
				this.paonby = ko.computed(function () {
					// b as a unit vector
					let ub1 = (b._p2.getX() - b._p1.getX()) / b.getSize();
					let ub2 = (b._p2.getY() - b._p1.getY()) / b.getSize();

					let angle = b.getAngleToX() - a.getAngleToX();

					// components of a along this unit vector
					let da2 = a.getSize() * Math.cos(angle) * ub2;

					return da2;
				});


				// calculate the projection of pb on vector a
				this.pbonax = ko.computed(function () {
					// a as a unit vector
					let ua1 = (a._p2.getX() - a._p1.getX()) / a.getSize();
					let ua2 = (a._p2.getY() - a._p1.getY()) / a.getSize();

					let angle = a.getAngleToX() - b.getAngleToX();

					// components of vector1 along this unit vector
					let db1 = b.getSize() * Math.cos(angle) * ua1;

					return db1;
				});
				this.pbonay = ko.computed(function () {
					// a as a unit vector
					let ua1 = (a._p2.getX() - a._p1.getX()) / a.getSize();
					let ua2 = (a._p2.getY() - a._p1.getY()) / a.getSize();

					let angle = a.getAngleToX() - b.getAngleToX();

					// components of vector1 along this unit vector
					let db1 = b.getSize() * Math.cos(angle) * ua2;

					return db1;
				});

				let paonb = new Point2Dim({x: this.paonbx, y: this.paonby}, {});

				let aonb = new Vector2Dim(
					{ p1: p0, p2: paonb },
					{ name: "aonb", showSize: 1, p1draggable: 0, p2draggable: 0, cssclass: "projectionaonb" }
				)
				let aonbprojl = new Vector2Dim(
					{ p1: pa, p2: paonb },
					{ showEndArrow: 0, p1draggable: 0, p2draggable: 0, cssclass: "projline" }
				)

				let pbona = new Point2Dim({x: this.pbonax, y: this.pbonay}, {});

				let bona = new Vector2Dim(
					{ p1: p0, p2: pbona },
					{ name: "bona", showSize: 1, p1draggable: 0, p2draggable: 0, cssclass: "projectionbona" }
				)
				let bonaprojl = new Vector2Dim(
					{ p1: pb, p2: pbona },
					{ showEndArrow: 0, p1draggable: 0, p2draggable: 0, cssclass: "projline" }
				)





				let angle1 = new VectorAngle2Dim(
					{ vs: a, ve: b },
					{ showAngle: 1 }
				);


				let getMathExpression = function () {
					let a1Formatted = d3.format(".2f")(pa.getX());
					let a2Formatted = d3.format(".2f")(pa.getY());
					let b1Formatted = d3.format(".2f")(pb.getX());
					let b2Formatted = d3.format(".2f")(pb.getY());

					let aLengthFormatted = d3.format(".2f")(a.getSize());
					let bLengthFormatted = d3.format(".2f")(b.getSize());

					let angleFormatted = d3.format(".2f")(angle1.getAngle());

					let dotProductFormatted = d3.format(".2f")(Vector2Dim.dotProduct(a, b));

					let mathExpression = "\\begin{aligned}"
						+ "c &= \\mathbf{a} \\cdot \\mathbf{b}\\\\"
						+ "&= " + a1Formatted + " * " + b1Formatted + " + " + a2Formatted + " * " + b2Formatted + "\\\\"
						+ "&= " + b1Formatted + " * " + a1Formatted + " + " + b2Formatted + " * " + a2Formatted + "\\\\"
						+ "&= \\mathbf{b} \\cdot \\mathbf{a}\\\\"
						+ "&= " + dotProductFormatted
						+ "\\end{aligned}";

					return mathExpression;
				}

				magnitudeMathExpression.RegisterExpression("dotproductcommutativity_sample", getMathExpression);


				this.p0x.subscribe(function (newValue) { space2dimvsum.update(); });
				this.p0y.subscribe(function (newValue) { space2dimvsum.update(); });
				this.a1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.a2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.b1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.b2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });


				//this.circlesToShow = [circle1];
				this.vectorsToShow = [a, b /*, aonb, aonbprojl, bona, bonaprojl*/];
				//this.anglesToShow = [angle1];

			}

			let vdp = new DotProductCommutativityViewModel();

			space2dimvsum.appenGlobalAttributes(Vector2Dim.global);
			space2dimvsum.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vdp.vectorsToShow; });
			//space2dimvsum.registerHandler(VectorAngle2Dim.draw, VectorAngle2Dim.update, function () { return vdp.anglesToShow; });
			space2dimvsum.show();

			return vdp;
		}

		function createDotProductDistributivitySample() {
			let magnitudeMathExpression = new MathExpressions();
			let space2dimvsum = new Space2Dim("dotproductdistributivity", 400, 400, -100, 100, -100, 100);

			function DotProductCommutativityViewModel() {
				this.p0x = ko.observable(0);
				this.p0y = ko.observable(0);

				this.a1 = ko.observable(80);
				this.a2 = ko.observable(60);

				this.b1 = ko.observable(10);
				this.b2 = ko.observable(50);

				this.c1 = ko.observable(20);
				this.c2 = ko.observable(-60);

				this.psumx = ko.computed(function () { return Number(this.b1()) + Number(this.c1()); }, this);
				this.psumy = ko.computed(function () { return Number(this.b2()) + Number(this.c2()); }, this);


				let p0 = new Point2Dim({x: this.p0x, y: this.p0y}, {});
				let pa = new Point2Dim({x: this.a1, y: this.a2}, {});
				let pb = new Point2Dim({x: this.b1, y: this.b2}, {});
				let pc = new Point2Dim({x: this.c1, y: this.c2}, {});

				let psum = new Point2Dim({x: this.psumx, y: this.psumy}, {});

				let a = new Vector2Dim(
					{ p1: p0, p2: pa },
					{ name: "a", dvaluelvl: 1, showSize: 0, p1draggable: 0, p2draggable: 1 }
				);

				let b = new Vector2Dim(
					{ p1: p0, p2: pb },
					{ name: "b", dvaluelvl: 2, showSize: 0, p1draggable: 0, p2draggable: 1 }
				);

				let c = new Vector2Dim(
					{ p1: p0, p2: pc },
					{ name: "c", dvaluelvl: 3, showSize: 0, p1draggable: 0, p2draggable: 1 }
				);

				let vsum = new Vector2Dim(
					{ p1: p0, p2: psum },
					{ name: "b+c", dvaluelvl: 4, p1draggable: 0, p2draggable: 0, cssclass: "calcresult" }
				);


				let paonc = new projectVectorOnVector(a, c);
				let aonc = new Vector2Dim(
					{ p1: p0, p2: paonc },
					{ name: "ap", showSize: 1, p1draggable: 0, p2draggable: 0, cssclass: "projectionaonb" }
				)
				let aoncprojl = new Vector2Dim(
					{ p1: pa, p2: paonc },
					{ showEndArrow: 0, p1draggable: 0, p2draggable: 0, cssclass: "projline" }
				)

				let pbonc = new projectVectorOnVector(b, c);
				let bonc = new Vector2Dim(
					{ p1: p0, p2: pbonc },
					{ name: "bp", showSize: 1, p1draggable: 0, p2draggable: 0, cssclass: "projectionaonb" }
				)
				let boncprojl = new Vector2Dim(
					{ p1: pb, p2: pbonc },
					{ showEndArrow: 0, p1draggable: 0, p2draggable: 0, cssclass: "projline" }
				)

				let psumonc = new projectVectorOnVector(vsum, c);
				let vsumonc = new Vector2Dim(
					{ p1: p0, p2: psumonc },
					{ name: "sump", showSize: 1, p1draggable: 0, p2draggable: 0, cssclass: "projectionaonb" }
				)
				let vsumoncprojl = new Vector2Dim(
					{ p1: psum, p2: psumonc },
					{ showEndArrow: 0, p1draggable: 0, p2draggable: 0, cssclass: "projline" }
				)



				let angle1 = new VectorAngle2Dim(
					{ vs: a, ve: b },
					{ showAngle: 1 }
				);


				let getMathExpression = function () {
					let a1Formatted = d3.format(".2f")(pa.getX());
					let a2Formatted = d3.format(".2f")(pa.getY());
					let b1Formatted = d3.format(".2f")(pb.getX());
					let b2Formatted = d3.format(".2f")(pb.getY());
					let c1Formatted = d3.format(".2f")(pc.getX());
					let c2Formatted = d3.format(".2f")(pc.getY());

					let dotProductFormatted = d3.format(".2f")(Vector2Dim.dotProduct(a, vsum));

					let mathExpression = "\\begin{aligned}"
						+ "d &= \\mathbf{a} \\cdot (\\mathbf{b}+\\mathbf{c})\\\\"
						+ "&= " + a1Formatted + " * (" + b1Formatted + " + " + c1Formatted + ") + " + a2Formatted + " * (" + b2Formatted + " + " + c2Formatted +") \\\\"
						+ "&= " + a1Formatted + " * " + b1Formatted + " + " + a1Formatted + " * " + c1Formatted + " + " + a2Formatted + " * " + b2Formatted + " + " + a2Formatted + " * " + c2Formatted + "\\\\"
						+ "&= " + dotProductFormatted
						+ "\\end{aligned}";

					return mathExpression;
				}

				magnitudeMathExpression.RegisterExpression("dotproductdistributive_sample", getMathExpression);


				this.p0x.subscribe(function (newValue) { space2dimvsum.update(); });
				this.p0y.subscribe(function (newValue) { space2dimvsum.update(); });
				this.a1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.a2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.b1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.b2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.c1.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });
				this.c2.subscribe(function (newValue) { space2dimvsum.update(); magnitudeMathExpression.QueueUpdate(); });


				this.vectorsToShow = [a, b, c, vsum/*, aonc, aoncprojl, bonc, boncprojl, vsumonc, vsumoncprojl*/];
				//this.anglesToShow = [angle1];

			}

			let vdp = new DotProductCommutativityViewModel();

			space2dimvsum.appenGlobalAttributes(Vector2Dim.global);
			space2dimvsum.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return vdp.vectorsToShow; });
			//space2dimvsum.registerHandler(VectorAngle2Dim.draw, VectorAngle2Dim.update, function () { return vdp.anglesToShow; });
			space2dimvsum.show();

			return vdp;
		}

		function ViewModel() {
			this.DotProd = createDotProductSample();
			this.DotProdComm = createDotProductCommutativitySample();
			this.DotProdDistr = createDotProductDistributivitySample();
		}

		let vm = new ViewModel();

		ko.applyBindings(vm);

	</script>

</body>
</html >
