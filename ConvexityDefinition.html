<!DOCTYPE html>
<html>
<head>
	<title>Definition of convexity</title>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
		showProcessingMessages: false,
		tex2jax: { inlineMath: [['$','$'],['\\(','\\)']] },
		TeX: { extensions: ["color.js"] }
		});
	</script>
	<script type="text/javascript" src="./MathJax-2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>
	<script type="text/javascript" src="./d3-selection-multi/d3-selection-multi.js"></script>
	<script type="text/javascript" src="./js/mathexpressions.js"></script>
	<script type="text/javascript" src="./js/space2dim.js"></script>
	<script type="text/javascript" src="./js/point.js"></script>
	<script type="text/javascript" src="./js/rico.js"></script>
	<script type="text/javascript" src="./js/circle.js"></script>
	<script type="text/javascript" src="./js/vector.js"></script>
	<script type="text/javascript" src="./js/line.js"></script>
	<script type="text/javascript" src="./js/region.js"></script>

	<link rel="stylesheet" type="text/css" href="./css/article.css">
	<link rel="stylesheet" type="text/css" href="./css/space2dim.css">
	<link rel="stylesheet" type="text/css" href="./css/vector.css">
	<link rel="stylesheet" type="text/css" href="./css/line.css">
	<link rel="stylesheet" type="text/css" href="./css/region.css">

	<style>
	</style>
</head>
<body>
	<div>
		<h1>Line segment</h1>
		<p>Two vector in 2-dimensional space:</p>
		<p>
			$$ \begin{aligned}
			\mathbf{a} &= (a_1, a_2), \text{ in }\mathbb{R}^2\\
			\mathbf{b} &= (b_1, b_2), \text{ in }\mathbb{R}^2
			\end{aligned}$$
		</p>
		<p>Then a line segment going from A to B can be defined as:</p>
		<p>
			$$r = \vec{oa} + \lambda \vec{ab}$$
		</p>
		<p>This is simply the adition of the vector $a$ with a part of the vector going from $a$ to $b$</p>
		<p>We know from the section on vector math that the vector going from $a$ to $b$ is equal to $b-a$ and thus we can write:</p>
		<p>
			$$\begin{aligned}
			r &= \vec{oa} + \lambda \vec{ab}\\
			&= A + {\lambda}(B-A) \\
			&= A + {\lambda}B-{\lambda}A \\
			&= (1-{\lambda})A + {\lambda}B \\
			&= ((1-{\lambda})a1 + {\lambda}b1, (1-{\lambda})a2 + {\lambda}b2) \\
			\end{aligned}$$
		</p>
		<p>A sample:</p>
		<div class="sample_container_height100">
			<div id="linesegment_sample">
				$${}$$
			</div>
		</div>
	</div>
	<div style="width:100%">
		<div class="divcentered">
			<input type="range" min="0" max="1" step="0.01" data-bind="value: LineSegment.lambda, valueUpdate: 'input'" />
		</div>
		<div id="linesegment" class="divcentered"></div>
	</div>
	<div>
		<h1>Convex</h1>
		<p>In a Euclidean space, a convex region is a region where, for every pair of points within the region, every point on the straight line segment that joins the pair of points is also within the region</p>
	</div>
	<div style="width:100%">
		<div class="divmanual">(You can drag the red dots to change the shape of the region. The black dots can be dragged to change the line segemnt. The slider can be dragged to change the point on the line segment. If the point on the linesegment is green, it is inside the region, else if it is red it is outside the region: then the region is not concave)</div>
		<div class="divcentered">
			<input type="range" min="0" max="1" step="0.01" data-bind="value: Convex.lambda, valueUpdate: 'input'" />
		</div>
		<div id="convex" class="divcentered"></div>
	</div>
	<div>
		<h1>Concave (not Convex)</h1>
		<p>If the region is not convext (see above for the definition) then it is concave.</p>
	</div>
	<div style="width:100%">
		<div class="divmanual">(You can drag the red dots to change the shape of the region. The black dots can be dragged to change the line segemnt. The slider can be dragged to change the point on the line segment. If the point on the linesegment is green, it is inside the region, else if it is red it is outside the region: then the region is not concave)</div>
		<div class="divcentered">
			<input type="range" min="0" max="1" step="0.01" data-bind="value: Concave.lambda, valueUpdate: 'input'" />
		</div>
		<div id="notconvex" class="divcentered"></div>
	</div>
	<script>

		function createLineSegmentDefinition() {
			var summationMathExpression = new MathExpressions();
			var space2dimlinesegment = new Space2Dim("linesegment", 300, 300, -50, 50, -50, 50);

			function LineSegmentViewModel() {

				this.lambda = ko.observable(0.5);
				this.lambda.subscribe(function (newValue) {
					space2dimlinesegment.update();
					summationMathExpression.QueueUpdate();
				});

				this.p0 = space2dimlinesegment.CreatePointAndUpdate(0, 0, function(){ summationMathExpression.QueueUpdate(); });
				this.p1 = space2dimlinesegment.CreatePointAndUpdate(-10, -20, function(){ summationMathExpression.QueueUpdate(); });
				this.p2 = space2dimlinesegment.CreatePointAndUpdate(40, 20, function(){ summationMathExpression.QueueUpdate(); });

				this.psx = ko.computed(function () {
					var x = (1 - this.lambda()) * this.p1.getX() + this.lambda() * this.p2.getX();
					//console.log("x: " + x)
					return x;
				}, this);
				this.psy = ko.computed(function () {
					var y = (1 - this.lambda()) * this.p1.getY() + this.lambda() * this.p2.getY();
					//console.log("y: " + y)
					return y;
				}, this);

				this.ps = new Point2Dim(this.psx, this.psy);

				var vector1 = new Vector2Dim(
					{ p1: this.p0, p2: this.p1 },
					{ name: "A", dvaluelvl: 1, p1draggable: 0, p2draggable: 1 }
				);

				var vector2 = new Vector2Dim(
					{ p1: this.p0, p2: this.p2 },
					{ name: "B", dvaluelvl: 2, p1draggable: 0, p2draggable: 1 }
				);

				var vsegment = new Vector2Dim(
					{ p1: this.p0, p2: this.ps },
					{ name: "V", showEndArrow: 1, dvaluelvl: 3, p1draggable: 0, p2draggable: 0 }
				);

				var linesegment = new Vector2Dim(
					{ p1: this.p1, p2: this.ps },
					{ name: "R", showEndArrow: 0, dvaluelvl: 0, p1draggable: 0, p2draggable: 0 }
				);

				var me = this;
				var getMathExpression = function () {
					var lambdaFormatted = d3.format(".1f")(me.lambda());
					var a1XFormatted = d3.format(".1f")(me.p1.getX());
					var a2YFormatted = d3.format(".1f")(me.p1.getY());
					var b1XFormatted = d3.format(".1f")(me.p2.getX());
					var b2YFormatted = d3.format(".1f")(me.p2.getY());
					var r1Formatted = d3.format(".1f")(me.ps.getX());
					var r2Formatted = d3.format(".1f")(me.ps.getY());

					//console.log("update linesegment equation");

					var mathExpression = 
						"\\begin{aligned}"
						+ "r &= a + {\\lambda}(b-a) \\\\"
						+ "&= (a1 + {\\lambda}(b1-a1), a2 + {\\lambda}(b2-a2)) \\\\"
						+ "&= ("+a1XFormatted+" + {" + lambdaFormatted + "}("+b1XFormatted+"-"+a1XFormatted+"), "+a2YFormatted+" + {" + lambdaFormatted + "}("+b2YFormatted+"-"+a2YFormatted+")) \\\\"
						+ "&= ("+r1Formatted+", "+r2Formatted+")"
						+ "\\end{aligned}";

					// var mathExpression = 
					// 	"\\begin{aligned} c &= (a_1 + b_1, a_2 + b_2) \\\\"
					// 	+ " &= (" + p1XFormatted + " + " + p2XFormatted + ", " + p1YFormatted + " + " + p2YFormatted + ") \\\\"
					// 	+ " &= (" + pSumXFormatted + ", " + pSumYFormatted + ")"
					// 	+ " \\end{aligned}";
					return mathExpression;
				}

				summationMathExpression.RegisterExpression("linesegment_sample", getMathExpression);

				this.circlesToShow = [];
				this.vectorsToShow = [vector1, vector2, vsegment, linesegment];
				this.raysToShow = [];
				this.poliesToShow = [];

			}

			var lnsgmnt = new LineSegmentViewModel();

			space2dimlinesegment.appenGlobalAttributes(Vector2Dim.global);
			space2dimlinesegment.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return lnsgmnt.raysToShow; });
			space2dimlinesegment.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return lnsgmnt.vectorsToShow; });
			space2dimlinesegment.registerHandler(Region2Dim.draw, Region2Dim.update, function () { return lnsgmnt.poliesToShow; });
			space2dimlinesegment.registerHandler(Circle.draw, Circle.update, function () { return lnsgmnt.circlesToShow; });
			space2dimlinesegment.show();

			return lnsgmnt;
		}

		function createConvexDefinition() {
			var space2dimconvex = new Space2Dim("convex", 300, 300, 0, 50, 0, 50);

			function ConvexDefinitionViewModel() {

				var p1 = space2dimconvex.CreatePoint(25, 15);
				var p2 = space2dimconvex.CreatePoint(35, 20);
				var p3 = space2dimconvex.CreatePoint(40, 25);
				var p4 = space2dimconvex.CreatePoint(35, 30);
				var p5 = space2dimconvex.CreatePoint(25, 35);
				var p6 = space2dimconvex.CreatePoint(15, 30);
				var p7 = space2dimconvex.CreatePoint(10, 25);
				var p8 = space2dimconvex.CreatePoint(15, 20);

				var regionPts = [p1, p2, p3, p4, p5, p6, p7, p8];

				var region1 = new Region2Dim({ poly: regionPts }, { draggable: 1 });

				var cnvxHandle1 = new Circle(
					{ center: p1, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle2 = new Circle(
					{ center: p2, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle3 = new Circle(
					{ center: p3, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle4 = new Circle(
					{ center: p4, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle5 = new Circle(
					{ center: p5, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle6 = new Circle(
					{ center: p6, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle7 = new Circle(
					{ center: p7, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle8 = new Circle(
					{ center: p8, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);


				this.sp1 = space2dimconvex.CreatePoint(15, 22);
				this.sp2 = space2dimconvex.CreatePoint(35, 25);
				var sp1Handle = new Circle(
					{ center: this.sp1, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var sp2Handle = new Circle(
					{ center: this.sp2, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);

				this.lambda = ko.observable(0.5);

				this.psx = ko.computed(function () {
					var x = (1 - this.lambda()) * this.sp1.getX() + this.lambda() * this.sp2.getX();
					//console.log("x: " + x)
					return x;
				}, this);
				this.psy = ko.computed(function () {
					var y = (1 - this.lambda()) * this.sp1.getY() + this.lambda() * this.sp2.getY();
					//console.log("y: " + y)
					return y;
				}, this);

				this.ps = new Point2Dim(this.psx, this.psy);
				var psHandle = new Circle(
					{ center: this.ps, radius: ko.observable(0.5) },
					{ draggable: 0, id: "cnvxsegmentend" }
				);

				var linesegment = new Vector2Dim(
					{ p1: this.sp1, p2: this.ps },
					{ name: "S", showEndArrow: 0, dvaluelvl: 0, p1draggable: 0, p2draggable: 0 }
				);

				this.lambdaDraw = function (space2Dim, d) {
					if (document.getElementById("cnvxsegmentend") == null)
						return;

					if (region1.Contains(segmentEndPt)) {
						//console.log("inside");
						document.getElementById("cnvxsegmentend").style.fill = "green";
					}
					else {
						//console.log("outside");
						document.getElementById("cnvxsegmentend").style.fill = "red";
					}
				}

				this.lambdaUpdate = function (space2Dim, d) {
					if (document.getElementById("cnvxsegmentend") == null)
						return;

					if (region1.Contains(segmentEndPt)) {
						//console.log("inside");
						document.getElementById("cnvxsegmentend").style.fill = "green";
					}
					else {
						//console.log("outside");
						document.getElementById("cnvxsegmentend").style.fill = "red";
					}
				}

				var segmentEndPt = this.ps;
				this.lambda.subscribe(function (newValue) {
					space2dimconvex.update();
				});


				this.circlesToShow = [
					//cnvxHandle1, cnvxHandle2, cnvxHandle3, cnvxHandle4, cnvxHandle5, cnvxHandle6, cnvxHandle7, cnvxHandle8
					sp1Handle, sp2Handle
					, psHandle];
				this.vectorsToShow = [linesegment];
				this.raysToShow = [];
				this.regionsToShow = [region1]

			}

			var cnvx = new ConvexDefinitionViewModel();

			space2dimconvex.appenGlobalAttributes(Vector2Dim.global);
			space2dimconvex.registerHandler(Region2Dim.draw, Region2Dim.update, function () { return cnvx.regionsToShow; });
			space2dimconvex.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return cnvx.raysToShow; });
			space2dimconvex.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return cnvx.vectorsToShow; });
			space2dimconvex.registerHandler(Circle.draw, Circle.update, function () { return cnvx.circlesToShow; });
			space2dimconvex.registerHandler(cnvx.lambdaDraw, cnvx.lambdaUpdate, function () { return []; });
			space2dimconvex.show();

			cnvx.lambdaUpdate(null, null);

			//ko.applyBindings(cnvx);

			return cnvx;

		}

		function createNotConvexDefinition() {
			var space2dimconvex = new Space2Dim("notconvex", 300, 300, 0, 50, 0, 50);

			function ConvexDefinitionViewModel() {

				var p1 = space2dimconvex.CreatePoint(25, 30);
				var p2 = space2dimconvex.CreatePoint(35, 20);
				var p3 = space2dimconvex.CreatePoint(40, 25);
				var p4 = space2dimconvex.CreatePoint(35, 30);
				var p5 = space2dimconvex.CreatePoint(25, 35);
				var p6 = space2dimconvex.CreatePoint(15, 30);
				var p7 = space2dimconvex.CreatePoint(10, 25);
				var p8 = space2dimconvex.CreatePoint(15, 20);

				var regionPts = [p1, p2, p3, p4, p5, p6, p7, p8];

				var region1 = new Region2Dim({ poly: regionPts }, { draggable: 1 });

				var cnvxHandle1 = new Circle(
					{ center: p1, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle2 = new Circle(
					{ center: p2, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle3 = new Circle(
					{ center: p3, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle4 = new Circle(
					{ center: p4, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle5 = new Circle(
					{ center: p5, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle6 = new Circle(
					{ center: p6, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle7 = new Circle(
					{ center: p7, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var cnvxHandle8 = new Circle(
					{ center: p8, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);


				this.sp1 = space2dimconvex.CreatePoint(15, 22);
				this.sp2 = space2dimconvex.CreatePoint(35, 25);
				var sp1Handle = new Circle(
					{ center: this.sp1, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);
				var sp2Handle = new Circle(
					{ center: this.sp2, radius: ko.observable(0.5) },
					{ draggable: 1 }
				);

				this.lambda = ko.observable(0.5);

				this.psx = ko.computed(function () {
					var x = (1 - this.lambda()) * this.sp1.getX() + this.lambda() * this.sp2.getX();
					//console.log("x: " + x)
					return x;
				}, this);
				this.psy = ko.computed(function () {
					var y = (1 - this.lambda()) * this.sp1.getY() + this.lambda() * this.sp2.getY();
					//console.log("y: " + y)
					return y;
				}, this);

				this.ps = new Point2Dim(this.psx, this.psy);
				var psHandle = new Circle(
					{ center: this.ps, radius: ko.observable(0.5) },
					{ draggable: 0, id: "notcnvxsegmentend" }
				);

				var linesegment = new Vector2Dim(
					{ p1: this.sp1, p2: this.ps },
					{ name: "S", showEndArrow: 0, dvaluelvl: 0, p1draggable: 0, p2draggable: 0 }
				);

				this.lambdaDraw = function (space2Dim, d) {
					if (document.getElementById("notcnvxsegmentend") == null)
						return;

					if (region1.Contains(segmentEndPt)) {
						//console.log("inside");
						document.getElementById("notcnvxsegmentend").style.fill = "green";
					}
					else {
						//console.log("outside");
						document.getElementById("notcnvxsegmentend").style.fill = "red";
					}
				}

				this.lambdaUpdate = function (space2Dim, d) {
					if (document.getElementById("notcnvxsegmentend") == null)
						return;

					if (region1.Contains(segmentEndPt)) {
						//console.log("inside");
						document.getElementById("notcnvxsegmentend").style.fill = "green";
					}
					else {
						//console.log("outside");
						document.getElementById("notcnvxsegmentend").style.fill = "red";
					}
				}

				var segmentEndPt = this.ps;
				this.lambda.subscribe(function (newValue) {
					space2dimconvex.update();
				});


				this.circlesToShow = [
					//cnvxHandle1, cnvxHandle2, cnvxHandle3, cnvxHandle4, cnvxHandle5, cnvxHandle6, cnvxHandle7, cnvxHandle8
					sp1Handle, sp2Handle
					, psHandle];
				this.vectorsToShow = [linesegment];
				this.raysToShow = [];
				this.regionsToShow = [region1]

			}

			var cnvx = new ConvexDefinitionViewModel();

			space2dimconvex.appenGlobalAttributes(Vector2Dim.global);
			space2dimconvex.registerHandler(Region2Dim.draw, Region2Dim.update, function () { return cnvx.regionsToShow; });
			space2dimconvex.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return cnvx.raysToShow; });
			space2dimconvex.registerHandler(Vector2Dim.draw, Vector2Dim.update, function () { return cnvx.vectorsToShow; });
			space2dimconvex.registerHandler(Circle.draw, Circle.update, function () { return cnvx.circlesToShow; });
			space2dimconvex.registerHandler(cnvx.lambdaDraw, cnvx.lambdaUpdate, function () { return []; });
			space2dimconvex.show();

			cnvx.lambdaUpdate(null, null);

			//ko.applyBindings(cnvx);

			return cnvx;
		}

		function ViewModel() {
			this.LineSegment = createLineSegmentDefinition();
			this.Convex = createConvexDefinition();
			this.Concave = createNotConvexDefinition();
		}

		var vm = new ViewModel();

		ko.applyBindings(vm);

	</script>
</body>
</html>