<!DOCTYPE html>
<!--

	Example for d3 and knockout databinding:
		https://stackoverflow.com/questions/26890141/databinding-a-d3-slider-with-knockout
			http://jsfiddle.net/v8tvkb4j/
		https://objectcomputing.com/resources/publications/sett/february-2014-d3-and-knockout

	google for "knockout binding circular uddate"

	https://stackoverflow.com/questions/25685842/knockout-avoid-circular-updates-in-a-binding
	https://knockoutjs.com/documentation/computed-dependency-tracking.html

	https://www.mathjax.org/

-->
<!--
to research
===========

*/ animate actions on a vector
	Move startpoint of a vector


*/ show the precpetron learning procedure (how will we do this ?)
	we could give points by clicking
		how will we differentiate between the two classes when clicking to give a point?
			OK: could we do this through the mousebutton in combination with a key? > d3.event.shiftKey
				mousebutton left click > class 1
				mousebutton left click + shift button > class 2

-->
<html>
<head>
	<title>KnockoutJS / D3 Perceptron Learning Testing ground</title>
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>
	<script type="text/javascript" src="./d3-selection-multi/d3-selection-multi.js"></script>

	<style>
		svg {
			font: 10px sans-serif;
			shape-rendering: geometricPrecision;
		}

		rect {
			fill: #fff;
		}

		.rayline {
			stroke: #000000;
			fill: #000000;
		}

		.perceptronboundary {
			stroke: #000000;
			fill: #000000;
		}

		.vectorline {
			stroke: #000000;
			fill: #000000;
		}

		.vectordx {
			stroke: #ff0000;
			fill: #000000;
		}

		.vectordy {
			stroke: #0000ff;
			fill: #000000;
		}

		.vectorendpoint {
			stroke: #000000;
			fill: #ff0000;
			fill-opacity: .5;
		}

		.vectorstartpoint {
			stroke: #000000;
			fill: #ff0000;
			fill-opacity: .5;
		}

		.perceptronResultPoint {
			stroke: #000000;
			fill: #d7d7d7;
		}

		.perceptronclass1 {
			stroke: #000000;
			fill: #ff6a00;
		}

		.perceptronclass2 {
			stroke: #000000;
			fill: #b6ff00;
		}

		.axis path,
		.axis line {
			fill: none;
			stroke: #d7d7d7;
		}
	</style>

</head>
<body>


	<p>p1x: <input data-bind="value: p1x" /></p>
	<p>p1y: <input data-bind="value: p1y" /></p>

	<div id="viz"></div>

	<script type="text/javascript">

		var spaceXMin = -75;
		var spaceXMax = 75;
		var spaceYMin = -75;
		var spaceYMax = 75;

		var rayGetYFromPtRico = function (xc, r) {
			//console.log("rayGetYFromPtRico ==================");
			//console.log("rayGetYFromPtRico > xc:" + xc );

			var xn = x(xc);
			//console.log("rayGetYFromPtRico > xn:" + xn);

			var ptxn = x(r.p.x());
			var ptyn = y(r.p.y());

			//console.log("rayGetYFromPtRico > ptxn:" + ptxn);
			//console.log("rayGetYFromPtRico > ptyn:" + ptyn);

			var dxn = x(r.p.x() + r.rico.dx()) - ptxn;
			var dyn = y(r.p.y() + r.rico.dy()) - ptyn;

			//console.log("rayGetYFromPtRico > dxn:" + dxn);
			//console.log("rayGetYFromPtRico > dyn:" + dyn);

			var res = ptyn - ((dxn) / (dyn)) * (xn - ptxn);
			//console.log("rayGetYFromPtRico > res:" + res);

			return res;
		}

		var rayGetXFromPtRico = function (yc, r) {
			//console.log("rayGetXFromPtRico ==================");
			//console.log("rayGetXFromPtRico > yc:" + yc);

			var yn = y(yc);
			//console.log("rayGetXFromPtRico > yn:" + yn);

			var ptxn = x(r.p.x());
			var ptyn = y(r.p.y());

			//console.log("rayGetXFromPtRico > ptxn:" + ptxn);
			//console.log("rayGetXFromPtRico > ptyn:" + ptyn);

			var dxn = x(r.p.x() + r.rico.dx()) - ptxn;
			var dyn = y(r.p.y() + r.rico.dy()) - ptyn;

			//console.log("rayGetXFromPtRico > dxn:" + dxn);
			//console.log("rayGetXFromPtRico > dyn:" + dyn);

			var res = ptxn - ((dyn) / (dxn)) * (yn - ptyn);
			//console.log("rayGetXFromPtRico > res:" + res);

			return res;
		}

		var rayGetYFromDRico = function (xc, r) {

			var res = (r.d() - (r.rico.dx() * xc)) / r.rico.dy();

			//console.log("rayGetYFromDRico d:" + r.d() + " - xc:" + xc + ", yres:" + res);
			return y(res);
		}

		var rayGetXFromDRico = function (yc, r) {

			var res = (r.d() - (r.rico.dy() * yc)) / r.rico.dx();

			//console.log("rayGetXFromDRico d:" + r.d() + " - yc:" + yc + ", xres:" + res);
			return x(res);
		}

		var calcRaySwap = function (rico) {
			var sr = Math.abs(spaceXMax - spaceXMin) / Math.abs(spaceYMax - spaceYMin);
			var rr = Math.abs(rico.dx()) / Math.abs(rico.dy());

			//console.log("calcRaySwap sr=" + sr + ", rr=" + rr);

			return false; //sr > rr;
		}

		var calcRayPRicoX1 = function (d) {
			var xval = 0;
			if (calcRaySwap(d.rico)) {
				xval = x(spaceXMin);
				//console.log("calcRayPRicoX1 [" + xval +"] > used x");
			}
			else {
				xval = rayGetXFromDRico(spaceYMin, d);
				//console.log("calcRayPRicoX1 [" + xval +"] > used rayGetXFromPtRico");
			}

			return xval;

		};
		var calcRayPRicoY1 = function (d) { return calcRaySwap(d.rico) ? rayGetYFromDRico(spaceXMin, d) : y(spaceYMin); };
		var calcRayPRicoX2 = function (d) { return calcRaySwap(d.rico) ? x(spaceXMax) : rayGetXFromDRico(spaceYMax, d); };
		var calcRayPRicoY2 = function (d) { return calcRaySwap(d.rico) ? rayGetYFromDRico(spaceXMax, d) : y(spaceYMax); };

		//var calcRayPRicoX1 = function (d) { return x(spaceXMin); };
		//var calcRayPRicoY1 = function (d) { return rayGetYFromPtRico(spaceXMin, d); };
		//var calcRayPRicoX2 = function (d) { return x(spaceXMax); };
		//var calcRayPRicoY2 = function (d) { return rayGetYFromPtRico(spaceXMax, d); };

		var updateFunc = function UpdateVector() {
			//console.log("UpdateVector ==================");

			var vectors = svg.selectAll(".vector")
				.data(vm.allVectors);

			vectors.select(".vectorstartpoint")
				//.attr("class", "vectorendpoint")
				//.style("stroke", "black")  // colour the line
				.attr("cx", function (d) { return x(d.p1.x()); })
				.attr("cy", function (d) { return y(d.p1.y()); })
				//.attr("r", "8px")
				//.attr("fill", "red")
				;

			vectors.select(".vectorendpoint")
				//.attr("class", "vectorendpoint")
				//.style("stroke", "black")  // colour the line
				.attr("cx", function (d) { return x(d.p2.x()); })
				.attr("cy", function (d) { return y(d.p2.y()); })
				//.attr("r", "8px")
				//.attr("fill", "red")
				;

			vectors.select(".vectorline")
				//.attr("class", "vectorline")
				//.style("stroke", "black")  // colour the line
				.attr("x1", function (d) { return x(d.p1.x()); })
				.attr("y1", function (d) { return y(d.p1.y()); })
				.attr("x2", function (d) { return x(d.p2.x()); })
				.attr("y2", function (d) { return y(d.p2.y()); })
				//.attr("marker-end", "url(#arrow)")
				;

			vectors.select(".vectorarc")
				//.attr("class", "vectorarc")
				.attr("d", function (d) { return vectorAngle(d); })
				//.attr("stroke", "blue")
				//.attr("stroke-width", 1)
				//.attr("fill", "none")
				//.attr("marker-end", "url(#arrow)")
				;


			//var rays = svg.selectAll(".ray")
			//	.data(vm.allRays);

			//rays.select(".rayline")
			//	//.attr("class", "rayline")
			//	.attr("x1", calcRayPRicoX1)
			//	.attr("y1", calcRayPRicoY1)
			//	.attr("x2", calcRayPRicoX2)
			//	.attr("y2", calcRayPRicoY2)
			//	;


			var perceptrons = svg.selectAll(".perceptron")
				.data(vm.allPerceptrons);

			perceptrons.select(".perceptronboundary")
				//.attr("class", "perceptronboundary")
				.attr("x1", calcPerceptronX1)
				.attr("y1", calcPerceptronY1)
				.attr("x2", calcPerceptronX2)
				.attr("y2", calcPerceptronY2)


			updatePerceptronResults();
		}

		var updatePerceptronResults = function UpdatePerceptronResults() {
			//console.log("UpdatePerceptronResults");

			//vm.allPerceptronResults.push({ x: xd, y:yd, class:1});

			var allResults = svg.selectAll(".perceptronResult").data(vm.allPerceptronResults());

			var newData = allResults.enter();

			gnew = newData
				.append("g")
				.attr("class", "perceptronResult")

			gnew.append("circle")
				//.attr("class", "perceptronResultPoint")
				.attr("class", function (d) { return (d.class == 1) ? "perceptronResultPoint perceptronclass1" : "perceptronResultPoint perceptronclass2"; })
				.attr("cx", function (d) { return x(d.x); })
				.attr("cy", function (d) { return y(d.y); })
				.attr("r", "3px")

			var updateData = allResults;

			var perceptron = vm.allPerceptrons[0];
			updateData.select(".perceptronResultPoint")
				.attr("class", function (d) {
					//d.class = calcPerceptronOutcome(perceptron, d.x, d.y);
					fillPerceptron(perceptron, d);
					return (d.class == 1) ? "perceptronResultPoint perceptronclass1" : "perceptronResultPoint perceptronclass2";
				})

		}

		function MyViewModel() {
			this.p0x = ko.observable(0)/*.extend({ number: true })*/;
			this.p0y = ko.observable(0)/*.extend({ number: true })*/;

			this.v1dx = ko.observable(-20);
			this.v1dy = ko.observable(30);

			this.v1dxnormal = ko.computed(function () {
				var v1dxval = Number(this.v1dx());
				var v1dyval = Number(this.v1dy());

				return v1dxval / Math.sqrt(v1dxval * v1dxval + v1dyval * v1dyval);
			}, this);
			this.v1dynormal = ko.computed(function () {
				var v1dxval = Number(this.v1dx());
				var v1dyval = Number(this.v1dy());

				return v1dyval / Math.sqrt(v1dxval * v1dxval + v1dyval * v1dyval);
			}, this);

			this.p1x = ko.computed(function () { return Number(this.p0x()) + Number(this.v1dx()); }, this);
			this.p1y = ko.computed(function () { return Number(this.p0y()) + Number(this.v1dy()); }, this);


			this.v2dx = ko.observable(35);
			this.v2dy = ko.observable(30);

			this.p2x = ko.computed(function () { return Number(this.p1x()) + Number(this.v2dx()); }, this);
			this.p2y = ko.computed(function () { return Number(this.p1y()) + Number(this.v2dy()); }, this);


			this.p3x = ko.observable(10)/*.extend({ number: true })*/;
			this.p3y = ko.observable(10)/*.extend({ number: true })*/;
			this.p4x = ko.observable(30)/*.extend({ number: true })*/;
			this.p4y = ko.observable(30)/*.extend({ number: true })*/;

			this.p5x = ko.observable(60)/*.extend({ number: true })*/;
			this.p5y = ko.observable(20)/*.extend({ number: true })*/;

			this.p0x.subscribe(function (newValue) { updateFunc(); });
			this.p0y.subscribe(function (newValue) { updateFunc(); });
			this.p1x.subscribe(function (newValue) { updateFunc(); });
			this.p1y.subscribe(function (newValue) { updateFunc(); });
			this.p2x.subscribe(function (newValue) { updateFunc(); });
			this.p2y.subscribe(function (newValue) { updateFunc(); });

			this.ray2d = ko.observable(10);

			this.vector = ko.observableArray([{ x: ko.observable(10)/*.extend({ number: true })*/ }, { x: ko.observable(20)/*.extend({ number: true })*/ }]);

			vector1 = {
				tp: "defp1delta",
				p1: { x: this.p0x, y: this.p0y },
				delta: { x: this.v1dx, y: this.v1dy },
				p2: { x: this.p1x, y: this.p1y }
			};
			vector2 = {
				tp: "defp1delta",
				p1: { x: this.p1x, y: this.p1y },
				delta: { x: this.v2dx, y: this.v2dy },
				p2: { x: this.p2x, y: this.p2y }
			};
			vector3 = {
				tp: "defp1p2",
				p1: { x: this.p3x, y: this.p3y },
				p2: { x: this.p4x, y: this.p4y }
			};
			vector4 = {
				tp: "defp1p2",
				p1: { x: this.p1x, y: this.p1y },
				p2: { x: this.p5x, y: this.p5y }
			};

			ray1 = {
				tp: "prico",
				p: { x: this.p0x, y: this.p0y },
				rico: { dx: this.v1dx, dy: this.v1dy }
			}
			ray2 = {
				tp: "drico",
				d: this.ray2d,
				rico: { dx: this.v1dxnormal, dy: this.v1dynormal }
			}

			var a = -20;
			var b = 30;
			var c = 1000;

			//this.pa = ko.observable(a / Math.sqrt(a*a + b*b));
			//this.pb = ko.observable(b / Math.sqrt(a * a + b * b));

			this.oa = ko.observable(a);
			this.ob = ko.observable(b);
			this.oc = ko.observable(c);

			this.oa.subscribe(function (newValue) { /*console.log("pa.subscribe");*/  updateFunc(); });
			this.ob.subscribe(function (newValue) { /*console.log("pb.subscribe");*/  updateFunc(); });
			this.oc.subscribe(function (newValue) { /*console.log("pc.subscribe");*/  updateFunc(); });

			this.pv1x = ko.observable(0);
			this.pv1y = ko.observable(0);

			this.pv2x = ko.computed(function () { return Number(this.pv1x()) + Number(this.oa()); }, this);
			this.pv2y = ko.computed(function () { return Number(this.pv1y()) + Number(this.ob()); }, this);

			vectorp = {
				tp: "defp1delta",
				p1: { x: this.pv1x, y: this.pv1y },
				delta: { x: this.oa, y: this.ob },
				p2: { x: this.pv2x, y: this.pv2y }
			};

			this.pa = ko.computed(function () {
				var a = Number(this.oa());
				var b = Number(this.ob());
				return a / Math.sqrt(a * a + b * b);
			}, this);

			this.pb = ko.computed(function () {
				var a = Number(this.oa());
				var b = Number(this.ob());
				return b / Math.sqrt(a * a + b * b);
			}, this);

			this.pc = ko.computed(function () {
				var a = Number(this.oa());
				var b = Number(this.ob());
				return -1 * Math.sqrt(a * a + b * b);  // *** WAAROM VERMENIGVULDIGEN MET -1 ???? ***
			}, this);

			perceptron1 = {
				a: this.pa,
				b: this.pb,
				c: this.pc
			};

			//v2 = {
			//	p1: { x: 0, y: 0 }, p2: { x: 40, y: 55 }
			//};
			//v3 = {
			//	p1: { x: 10, y: 20 }, p2: { x: 50, y: 70 }
			//};

			//vs = [v1, v2, v3];
			this.allVectors = [vectorp]; //, vector2, vector3, vector4];
			this.allRays = []; //[ray2];
			this.allPerceptrons = [perceptron1];
			this.allPerceptronResults = ko.observableArray([]);
			this.allPerceptronResults.subscribe(function (newValue) { console.log("allPerceptronResults.subscribe"); updatePerceptronResults(); });

		}

		var vm = new MyViewModel();




		var margin = { top: 40, right: 40, bottom: 40, left: 40 },
			width = 200,
			height = 200;
		var x = d3.scaleLinear()
			.domain([spaceXMin, spaceXMax])
			.range([0, width]);
		var y = d3.scaleLinear()
			.domain([spaceYMin, spaceYMax])
			.range([height, 0]);
		var xAxis = d3.axisBottom()
			.scale(x)
			.ticks(10)
			.tickSize(-height);
		var yAxis = d3.axisLeft()
			.scale(y)
			.ticks(10)
			.tickSize(-width);
		var svg = d3.select("#viz").append("svg")
			.attr("width", width + margin.left + margin.right)
			.attr("height", height + margin.top + margin.bottom);


		svg.append("g")
			.attr("transform", "translate(" + margin.left + "," + margin.top + ")");
		svg.append("rect")
			.attr("width", width)
			.attr("height", height);
		svg.append("g")
			.attr("class", "x axis")
			.attr("transform", "translate(0," + height + ")")
			.call(xAxis);
		svg.append("g")
			.attr("class", "y axis")
			.call(yAxis);

		var calcPerceptronOutcome = function CalcPerceptronOutcome(p, x, y) {
			var r = p.a() * x + p.b() * y + p.c();
			return (r > 0) ? 1 : 0;
		}

		var fillPerceptron = function FillPerceptron(p, d) {
			d.class = calcPerceptronOutcome(p, d.x, d.y);
		}

		var createPerceptron = function CreatePerceptron(p, x, y) {
			var pdata = { x: x, y: y, class: 0 };
			fillPerceptron(p, pdata);
			return pdata;
		}

		var moveVectorByP1ToPositionAnimated = function MoveVectorByP1ToPositionAnimated(line, v, xt, yt) {
			var vx1 = v.p1.x();
			var vy1 = v.p1.y();

			var dxt = xt - vx1;
			var dyt = yt - vy1;

			var xs = x(xt);
			var ys = y(yt)

			if (v.tp == "defp1delta") {
				var vx2t = vx1 + v.delta.x() + dxt;
				var vy2t = vy1 + v.delta.y() + dyt;

				line.transition()
					.duration(1500)
					.attrs({
						x1: xs,
						y1: ys,
						x2: x(vx2t),
						y2: y(vy2t)
					})
					.on("end", function () {
						console.log("line transition ended");

						v.p1.x(xt);
						v.p1.y(yt);

						updateFunc();
					});

			}
			else if (v.tp == "defp1p2") {
				console.log("unsupported in this POC");
			}
		}

		svg.on("click", function () {

			//event.preventDefault();

			console.log("svg clicked with shiftkey[" + d3.event.shiftKey + "]");
			//console.log("svg clicked with mousebutton[" + d3.event.button + "]");

			var coords = d3.mouse(this);

			var xd = x.invert(coords[0]);
			var yd = y.invert(coords[1]);

			console.log("svg clicked at coord[" + coords[0] + "," + coords[1] + "], domain[" + xd + "," + yd + "]");

			var perceptron = vm.allPerceptrons[0];
			vm.allPerceptronResults.push(createPerceptron(perceptron, xd, yd));


			svg.select(".vectorline")
				.call(function (e) {
					console.log("call function for vectorline " + e);

					moveVectorByP1ToPositionAnimated(e, vm.allVectors[0], xd, yd);
				});


			//var x1t = coords[0];
			//var y1t = coords[1];
			//var x2t = x(xd + 10);
			//var y2t = y(yd + 20);
			////console.log("svg clicked x0[" + x0 + "], y0[" + y0 + "]");

			////http://www.d3noob.org/2014/02/styles-in-d3js.html

			//svg.append('line')
			//	//.attr("class", "vectorline")
			//	.attrs({
			//		x1: x(0),
			//		y1: y(0),
			//		x2: x(10),
			//		y2: y(20)
			//	})
			//	.style("stroke", "#000000")
			//	.style("stroke-width", 1)
			//	//.attr("x1", 0)
			//	//.attr("y1", 0)
			//	//.attr("x2", 25)
			//	//.attr("y2", 15)
			//	.attr("marker-end", "url(#linearrow)")
			//	.transition()
			//	.duration(1500)
			//	.style("stroke", "#FF0000")
			//	.style("stroke-width", 2)
			//	.transition()
			//	.duration(1500)
			//	.attrs({
			//		x1: x1t,
			//		y1: y1t,
			//		x2: x2t,
			//		y2: y2t
			//	})
			//	.transition()
			//	.duration(1500)
			//	.style("stroke", "#000000")
			//	.style("stroke-width", 1)
			//	// notify the transition ended
			//	.on("end", function () {
			//		console.log("line transition ended");
			//	});



			//svg.select("#linearrow")
			//	.select("path")
			//	.transition()
			//	.duration(1500)
			//	.style("fill", "#0000FF")
			//	.on("end", function () { console.log("marker transition ended"); });


			//// what we sill need to find out
			////	* OK how to animate the marker
			////		- its color
			////		- its scale
			////		- its shape
			////	* OK notification of the transition ending,
			//		to be able to update the values of the viewmodel to which the animated object is connected


		});

		//v1 = {
		//	p1: { x: 0, y: 0 }, p2: { x: 10, y: 40 }
		//};
		//v2 = {
		//	p1: { x: 0, y: 0 }, p2: { x: 40, y: 55 }
		//};
		//v3 = {
		//	p1: { x: 10, y: 20 }, p2: { x: 50, y: 70 }
		//};

		//vs = [v1, v2, v3];
		//vs = [v1];


		svg.append("svg:defs").append("marker")
			//.attr("class", "vectorline")
			.attr("id", "linearrow")
			.attr("refX", 10)
			.attr("refY", 3)
			.attr("markerWidth", 20)
			.attr("markerHeight", 20)
			.attr("markerUnits", "userSpaceOnUse")
			.attr("orient", "auto")
			.append("path")
			.attr("d", "M 0 0 10 3 0 6")
			.style("fill", "#FF0000")
			;


		var perceptronGetX = function (yc, p) {

			var res = -1 * (p.c() + (p.b() * yc)) / p.a();

			console.log("perceptronGetX a:" + p.a() + " b:" + p.b() + " c:" + p.c() + " - yc:" + yc + ", xres:" + res);
			return x(res);
		}

		var perceptronGetY = function (xc, p) {

			var res = -1 * (p.c() + (p.a() * xc)) / p.b();

			console.log("perceptronGetX a:" + p.a() + " b:" + p.b() + " c:" + p.c() + " - xc:" + xc + ", xres:" + res);
			return y(res);
		}

		var calcPerceptronSwap = function (a, b) {
			var sr = Math.abs(spaceXMax - spaceXMin) / Math.abs(spaceYMax - spaceYMin);
			var rr = Math.abs(a()) / Math.abs(b());

			console.log("calcRaySwap sr=" + sr + ", rr=" + rr);

			return sr > rr;
		}

		var calcPerceptronX1 = function (d) {
			var xval = 0;
			if (calcPerceptronSwap(d.a, d.b)) {
				xval = x(spaceXMin);
				//console.log("calcRayPRicoX1 [" + xval +"] > used x");
			}
			else {
				xval = perceptronGetX(spaceYMin, d);
				//console.log("calcRayPRicoX1 [" + xval +"] > used rayGetXFromPtRico");
			}

			return xval;

		};
		var calcPerceptronY1 = function (d) { return calcPerceptronSwap(d.a, d.b) ? perceptronGetY(spaceXMin, d) : y(spaceYMin); };
		var calcPerceptronX2 = function (d) { return calcPerceptronSwap(d.a, d.b) ? x(spaceXMax) : perceptronGetX(spaceYMax, d); };
		var calcPerceptronY2 = function (d) { return calcPerceptronSwap(d.a, d.b) ? perceptronGetY(spaceXMax, d) : y(spaceYMax); };





		var perceptronData = svg.selectAll(".perceptron")
			.data(vm.allPerceptrons).enter()

		gperceptron = perceptronData
			.append("g")
			.attr("class", "perceptron");

		gperceptron.append("line")
			.attr("class", "perceptronboundary")
			.attr("x1", calcPerceptronX1)
			.attr("y1", calcPerceptronY1)
			.attr("x2", calcPerceptronX2)
			.attr("y2", calcPerceptronY2)





		rayData = svg.selectAll(".ray")
			.data(vm.allRays).enter()

		gray = rayData
			.append("g")
			.attr("class", "ray");

		gray.append("line")
			.attr("class", "rayline")
			.attr("x1", calcRayPRicoX1)
			.attr("y1", calcRayPRicoY1)
			.attr("x2", calcRayPRicoX2)
			.attr("y2", calcRayPRicoY2)





		data = svg.selectAll(".vector")
			.data(vm.allVectors).enter()

		g = data
			.append("g")
			.attr("class", "vector");

		g.append("circle")
			.attr("class", function (d) { return (d.tp == "defp1p2") ? "vectorendpoint defp1p2" : "vectorendpoint defp1delta"; })
			//.style("stroke", "black")  // colour the line
			.attr("cx", function (d) { return x(d.p2.x()); })
			.attr("cy", function (d) { return y(d.p2.y()); })
			.attr("r", "8px")
			//.attr("fill", "red")
			;

		//g.append("circle")
		//	.attr("class", "vectorstartpoint")
		//	//.style("stroke", "black")  // colour the line
		//	.attr("cx", function (d) { return x(d.p1.x()); })
		//	.attr("cy", function (d) { return y(d.p1.y()); })
		//	.attr("r", "8px")
		//	//.attr("fill", "red")
		;

		g.append("line")          // attach a line
			.attr("class", function (d) { return (d.tp == "defp1p2") ? "vectorline" : "vectorline defp1delta"; })
			//.attr("class", "vectorline defp1delta")
			//.style("stroke", "black")  // colour the line
			.attr("x1", function (d) { return x(d.p1.x()); })
			.attr("y1", function (d) { return y(d.p1.y()); })
			.attr("x2", function (d) { return x(d.p2.x()); })
			.attr("y2", function (d) { return y(d.p2.y()); })
			.attr("marker-end", "url(#linearrow)")
			;



		// https://www.dashingd3js.com/svg-paths-and-d3js
		// https://stackoverflow.com/questions/45120229/how-to-draw-arc-with-d3-js-with-only-outer-radius-or-sector-of-circle
		// https://www.tutorialspoint.com/d3js/d3js_paths_api.htm

		//var lineData = [{ "x": 1, "y": 5 }, { "x": 20, "y": 20 },
		//	                 { "x": 40, "y": 10 }, { "x": 60, "y": 40 },
		//	                 { "x": 80, "y": 5 }, { "x": 100, "y": 60 }];

		//var lineFunction = d3.line()
		//	.x(function (d) { return d.x; })
		//	.y(function (d) { return d.y; })
		//	.curve(d3.curveLinear);

		g.append("line")
			.attr("class", "vectordx")
			.attr("x1", function (d) { return x(d.p1.x()); })
			.attr("y1", function (d) { return y(d.p1.y()); })
			.attr("x2", function (d) { return x(d.p2.x()); })
			.attr("y2", function (d) { return y(d.p1.y()); })
			;

		g.append("text")
			.attr("class", "vectorvaluedx")
			.style("text-anchor", "middle")
			.text(function (d) { return (d.p2.x() - d.p1.x()); })
			.attr("x", function (d) { return x(d.p1.x() + (d.p2.x() - d.p1.x()) / 2); })
			.attr("y", function (d) { return y(d.p1.y()) - 5; })
			;

		g.append("line")
			.attr("class", "vectordy")
			.attr("x1", function (d) { return x(d.p2.x()); })
			.attr("y1", function (d) { return y(d.p1.y()); })
			.attr("x2", function (d) { return x(d.p2.x()); })
			.attr("y2", function (d) { return y(d.p2.y()); })
			;

		g.append("text")
			.attr("class", "vectorvaluedy")
			.style("text-anchor", "middle")
			.text(function (d) { return (d.p2.y() - d.p1.y()); })
			.attr("x", function (d) { return x(d.p1.x()) - 5; })
			.attr("y", function (d) { return y(d.p1.y() + (d.p2.y() - d.p1.y()) / 2); })
			;


		//let dragp1 = d3.drag()
		//	.on('start', dragstarted)
		//	.on('drag', draggedp1)
		//	.on('end', dragended);

		let defp1delta_dragp2 = d3.drag()
			.on('start', dragstarted)
			.on('drag', defp1delta_draggedp2)
			.on('end', dragended);

		let defp1p2_dragp2 = d3.drag()
			.on('start', dragstarted)
			.on('drag', defp1p2_draggedp2)
			.on('end', dragended);

		//svg.selectAll('.vectorstartpoint')
		//	.call(dragp1);

		svg.selectAll('.vectorendpoint.defp1delta')
			.call(defp1delta_dragp2);

		svg.selectAll('.vectorendpoint.defp1p2')
			.call(defp1p2_dragp2);

		function dragstarted(d) {
			//d3.select(this).raise().classed('active', true);
		}

		function draggedp1(d) {
			//console.log("draggedp1");
			//console.log(this);
			//console.log(d);

			d.p1.x(x.invert(d3.event.x));
			d.p1.y(y.invert(d3.event.y));

			d3.select(this)
				.attr('cx', x(d.p1.x()))
				.attr('cy', y(d.p1.y()))
			//focus.select('path').attr('d', line);
			//console.log(d3.select(this.parentNode)
			//	.select('.vectorline'));

			d3.select(this.parentNode)
				.select('.vectorline')
				.attr("x1", x(d.p1.x()))
				.attr("y1", y(d.p1.y()))

			//d3.select(this.parentNode)
			//	.select('.vectorp1x')
			//	.attr("x1", x(d.p1.x()))
			//	.attr("y1", y(-10))
			//	.attr("x2", x(d.p1.x()))
			//	.attr("y2", y(d.p1.y()))

			d3.select(this.parentNode)
				.select('.vectorvaluedx')
				.text((d.p2.x() - d.p1.x()))
				.attr("x", x(d.p1.x() + (d.p2.x() - d.p1.x()) / 2))
				.attr("y", function (d) { return y(d.p1.y()) - 5; })

			d3.select(this.parentNode)
				.select(".vectorvaluedy")
				.text(function (d) { return (d.p2.x() - d.p1.x()); })
				.attr("x", function (d) { return x(d.p1.x()) - 5; })
				.attr("y", function (d) { return y(d.p1.y() + (d.p2.y() - d.p1.y()) / 2); })
				;

		}

		function defp1delta_draggedp2(d) {
			//console.log("defp1delta_draggedp2");
			//console.log(this);
			//console.log(d);

			var newX = x.invert(d3.event.x);
			var newY = y.invert(d3.event.y);

			d.delta.x(newX - Number(d.p1.x()));
			d.delta.y(newY - Number(d.p1.y()));

			//d.p2.x(x.invert(d3.event.x));
			//d.p2.y(y.invert(d3.event.y));

			d3.select(this)
				.attr('cx', x(d.p2.x()))
				.attr('cy', y(d.p2.y()))
			//focus.select('path').attr('d', line);
			//console.log(d3.select(this.parentNode)
			//	.select('.vectorline'));

			d3.select(this.parentNode)
				.select('.vectorline')
				.attr("x2", x(d.p2.x()))
				.attr("y2", y(d.p2.y()))

			d3.select(this.parentNode)
				.select('.vectordx')
				.attr("x1", function (d) { return x(d.p1.x()); })
				.attr("y1", function (d) { return y(d.p1.y()); })
				.attr("x2", function (d) { return x(d.p2.x()); })
				.attr("y2", function (d) { return y(d.p1.y()); })

			d3.select(this.parentNode)
				.select('.vectorvaluedx')
				.text((d.p2.x() - d.p1.x()))
				.attr("x", x(d.p1.x() + (d.p2.x() - d.p1.x()) / 2))
				.attr("y", function (d) { return y(d.p1.y()) - 5; })

			d3.select(this.parentNode)
				.select('.vectordy')
				.attr("x1", function (d) { return x(d.p2.x()); })
				.attr("y1", function (d) { return y(d.p1.y()); })
				.attr("x2", function (d) { return x(d.p2.x()); })
				.attr("y2", function (d) { return y(d.p2.y()); })

			d3.select(this.parentNode)
				.select(".vectorvaluedy")
				.text(function (d) { return (d.p2.y() - d.p1.y()); })
				.attr("x", function (d) { return x(d.p1.x()) - 5; })
				.attr("y", function (d) { return y(d.p1.y() + (d.p2.y() - d.p1.y()) / 2); })
				;

		}

		function defp1p2_draggedp2(d) {
			//console.log("defp1delta_draggedp2");
			//console.log(this);
			//console.log(d);

			//var newX = x.invert(d3.event.x);
			//var newY = y.invert(d3.event.y);

			//d.delta.x(newX - Number(d.p1.x()));
			//d.delta.y(newY - Number(d.p1.y()));

			d.p2.x(x.invert(d3.event.x));
			d.p2.y(y.invert(d3.event.y));

			d3.select(this)
				.attr('cx', x(d.p2.x()))
				.attr('cy', y(d.p2.y()))
			//focus.select('path').attr('d', line);
			//console.log(d3.select(this.parentNode)
			//	.select('.vectorline'));

			d3.select(this.parentNode)
				.select('.vectorline')
				.attr("x2", x(d.p2.x()))
				.attr("y2", y(d.p2.y()))

			d3.select(this.parentNode)
				.select('.vectorp2x')
				.attr("x1", x(d.p2.x()))
				.attr("y1", y(d.p1.y()))
				.attr("x2", x(d.p2.x()))
				.attr("y2", y(d.p2.y()))

			d3.select(this.parentNode)
				.select('.vectorvaluedx')
				.text((d.p2.x() - d.p1.x()))
				.attr("x", x(d.p1.x() + (d.p2.x() - d.p1.x()) / 2))
				.attr("y", y(-10))

			d3.select(this.parentNode)
				.select(".vectorvaluedy")
				.text(function (d) { return (d.p2.y() - d.p1.y()); })
				.attr("x", function (d) { return x(d.p1.x()) - 5; })
				.attr("y", function (d) { return y(d.p1.y() + (d.p2.y() - d.p1.y()) / 2); })
				;

		}

		function dragended(d) {
			//d3.select(this).classed('active', false);
		}

		// Activates knockout.js
		ko.applyBindings(vm);
	</script>

</body>
</html>