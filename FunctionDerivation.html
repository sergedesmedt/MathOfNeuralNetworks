<!DOCTYPE html>
<html>
<head>
	<title>Learn Function Derivation</title>
	<!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
	<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/knockout/3.4.2/knockout-debug.js"></script>
	<script type="text/javascript" src="https://d3js.org/d3.v5.min.js"></script>
	<script type="text/javascript" src="https://d3js.org/d3-selection-multi.v1.min.js"></script>-->
	<script type="text/javascript" src="./ko/knockout-3.4.2.debug.js"></script>
	<script type="text/javascript" src="./d3/d3.v5.js"></script>
	<script type="text/javascript" src="./d3-selection-multi/d3-selection-multi.js"></script>
	<script type="text/javascript" src="./mathjax-2.7.5/MathJax.js?config=TeX-MML-AM_HTMLorMML"></script>
	<script type="text/javascript" src="./js/space2dim.js"></script>
	<script type="text/javascript" src="./js/point.js"></script>
	<script type="text/javascript" src="./js/circle.js"></script>
	<script type="text/javascript" src="./js/vector.js"></script>
	<script type="text/javascript" src="./js/mathfunction.js"></script>
	<script type="text/javascript" src="./js/rico.js"></script>
	<script type="text/javascript" src="./js/line.js"></script>

	<link rel="stylesheet" type="text/css" href="./css/article.css">
	<link rel="stylesheet" type="text/css" href="./css/space2dim.css">
	<link rel="stylesheet" type="text/css" href="./css/vector.css">
	<link rel="stylesheet" type="text/css" href="./css/line.css">

	<style>
		.funcplot {
			stroke: #000000;
			stroke-width: 1;
			fill: none;
		}
	</style>
</head>
<body>
	<div>
		<h1>Limit</h1>
		<input type="range" min="-50" max="0" step="1" data-bind="value: LimitSample.leftApproach, valueUpdate: 'input'" />
		<input type="range" min="0" max="50" step="1" data-bind="value: LimitSample.rightApproach, valueUpdate: 'input'" />
		<div id="limitSample"></div>
	</div>
	<div>
		<h1>Continuity</h1>
		<input type="range" min="-50" max="0" step="1" data-bind="value: ContinuitySample.leftApproach, valueUpdate: 'input'" />
		<input type="range" min="0" max="50" step="1" data-bind="value: ContinuitySample.rightApproach, valueUpdate: 'input'" />
		<div id="continuitySample"></div>
	</div>
	<div>
		<h1>Derivative of a function</h1>
		<div id="functionderivative_sample">

		</div>
		<div style="width:100%">
			<div id="functionderivationanimation"></div>
		</div>
	</div>

	<script type="text/javascript">

		function createLimitSample()
		{
			let space = new Space2Dim("limitSample", 300, 300, -50, 50, -10, 40);

			function ViewModel() {
				let leftFuncFactory = function() {
					let f = function (x) {
						return 0.01 * x * x + 10;
					}

					return f;
				}

				let rightFuncFactory = function () {
					let f = function (x) {
						return 0.01 * x * x + 20;
					}

					return f;
				}

				let leftMathFunc = leftFuncFactory();
				let rightMathFunc = rightFuncFactory();

				let p0Value = new Point2Dim({
					x: ko.observable(0),
					y: ko.observable(15)
				}, {});;

				let p0Visual = new Circle(
					{ center: p0Value, radius: ko.observable(1.5) },
					{ draggable: 0 }
				);

				this.leftApproach = ko.observable(-25);
				this.leftApproachY = ko.computed(function () {
					return leftMathFunc(this.leftApproach());
				}, this);

				this.rightApproach = ko.observable(25);
				this.rightApproachY = ko.computed(function () {
					return rightMathFunc(this.rightApproach());
				}, this);

				this.leftApproach.subscribe(function (newValue) { space.update(); });
				this.rightApproach.subscribe(function (newValue) { space.update(); });


				let pLeftApproach = new Point2Dim({ x: this.leftApproach, y: this.leftApproachY }, {});
				let pRightApproach = new Point2Dim({ x: this.rightApproach, y: this.rightApproachY }, {});

				let leftFunc = new Function2Dim({ func: leftFuncFactory() }, { domain: [Number.MIN_SAFE_INTEGER, 0] });
				let rightFunc = new Function2Dim({ func: rightFuncFactory() }, { domain: [0, Number.MAX_SAFE_INTEGER] });

				this.circlesToShow = [p0Visual];
				this.pointsToShow = [pLeftApproach, pRightApproach];
				this.funcsToShow = [leftFunc, rightFunc];
			}

			let vmfunc = new ViewModel();

			space.registerHandler(Point2Dim.draw, Point2Dim.update, function () { return vmfunc.pointsToShow; });
			space.registerHandler(Function2Dim.draw, Function2Dim.update, function () { return vmfunc.funcsToShow; });
			space.registerHandler(Circle.draw, Circle.update, function () { return vmfunc.circlesToShow; });

			space.show();

			return vmfunc;
		}

		function createContinuitySample() {
			let space = new Space2Dim("continuitySample", 300, 300, -50, 50, -50, 50);

			function ViewModel() {
				let funcFactory = function () {
					let f = function (x) {
						return Math.abs(x);
					};

					return f;
				};

				let func = funcFactory();

				let p0Value = new Point2Dim({
					x: ko.observable(0),
					y: ko.computed(function () {
						return func(0);
					})
				}, {});;

				let p0Visual = new Circle(
					{ center: p0Value, radius: ko.observable(1.5) },
					{ draggable: 0 }
				);

				this.leftApproach = ko.observable(-25);
				this.leftApproachY = ko.computed(function () {
					return func(this.leftApproach());
				}, this);

				this.rightApproach = ko.observable(25);
				this.rightApproachY = ko.computed(function () {
					return func(this.rightApproach());
				}, this);

				this.leftApproach.subscribe(function (newValue) { space.update(); });
				this.rightApproach.subscribe(function (newValue) { space.update(); });

				let pLeftApproach = new Point2Dim({ x: this.leftApproach, y: this.leftApproachY }, {});
				let pRightApproach = new Point2Dim({ x: this.rightApproach, y: this.rightApproachY }, {});



				let theFunc = new Function2Dim({ func: func }, { });


				this.circlesToShow = [p0Visual];
				this.pointsToShow = [pLeftApproach, pRightApproach];
				this.funcsToShow = [theFunc];

			}

			let vmfunc = new ViewModel();

			space.registerHandler(Point2Dim.draw, Point2Dim.update, function () { return vmfunc.pointsToShow; });
			space.registerHandler(Circle.draw, Circle.update, function () { return vmfunc.circlesToShow; });
			space.registerHandler(Function2Dim.draw, Function2Dim.update, function () { return vmfunc.funcsToShow; });

			space.show();

			return vmfunc;
		}

		function createFunctionDerivationAnimationSample() {
			let space2dimvsum = new Space2Dim("functionderivationanimation", 300, 300, -50, 50, -50, 50);

			function ViewModel() {

				this.amplx = ko.observable(30);
				this.amply = ko.observable(0);

				this.amplx.subscribe(function (newValue) { space2dimvsum.update(); });
				this.amply.subscribe(function (newValue) { space2dimvsum.update(); });

				let pampl = new Point2Dim({x: this.amplx, y: this.amply}, {});

				let ampl = this.amplx;
				let generateRandomCurve = function () {
					//let amplitude = ampl();

					//console.log("amplitude: " + amplitude);

					let n = 1; //Math.floor(Math.random() * 4 + 1);

					let spectrRange = d3.range(0, 1);
					//for (i = 0; i < spectrRange.length; i++) {
					//	console.log("range[" + i + "] = " + spectrRange[i]);
					//}

					let params = spectrRange.map(function () {
						return [
							0.01 /*Math.random()*/ * (2 * Math.PI),		// frequency
							0 ///*Math.random()*/ * Math.PI - Math.PI	// shift
						]; // [ FREQUENCY , SHIFT ]
					});
					for (i = 0; i < params.length; i++) {
						//console.log("params[" + i + "] = " + params[i][0] +","+ params[i][1]);
					}

					let f = function (x) {
						let spectrSin = params.map(function (d) { return Math.sin(d[0] * x + d[1]); });
						for (i = 0; i < spectrSin.length; i++) {
							//console.log("spectrSin[" + i + "] = " + spectrSin[i]);
						}
						var result = ampl() * (d3.sum(spectrSin) /*/ (3 * n) + 0.5*/);
						//console.log("generateRandomCurve x["+x+"], result[" + result + "]");
						return result;
					};

					return f;
				};

				let curveFunc = generateRandomCurve();

				//this.p0x = ko.observable(0);
				//this.p0y = ko.observable(0);
				this.p1x = ko.observable(-30);
				this.p1y = ko.computed(function () {
					return curveFunc(this.p1x());
				}, this); //ko.observable(-6);
				this.p2x = ko.observable(30);
				this.p2y = ko.computed(function () {
					return curveFunc(this.p2x());
				}, this); //ko.observable(6);

				//this.p3x = ko.observable(20);
				//this.p3y = ko.observable(5);


				//this.p0x.subscribe(function (newValue) { space2dimvsum.update(); });
				//this.p0y.subscribe(function (newValue) { space2dimvsum.update(); });
				this.p1x.subscribe(function (newValue) { space2dimvsum.update(); });
				//this.p1y.subscribe(function (newValue) { space2dimvsum.update(); });
				this.p2x.subscribe(function (newValue) { space2dimvsum.update(); });
				//this.p2y.subscribe(function (newValue) { space2dimvsum.update(); });
				//this.p3x.subscribe(function (newValue) { space2dimvsum.update(); });
				//this.p3y.subscribe(function (newValue) { space2dimvsum.update(); });

				//let p0 = new Point2Dim({x: this.p0x, y: this.p0y}, {});
				let pl1 = new Point2Dim({x: this.p1x, y: this.p1y}, {});
				let pl2 = new Point2Dim({x: this.p2x, y: this.p2y}, {});

				//let pref3 = new Point2Dim({x: this.p3x, y: this.p3y}, {});

				let ray = new Line2Dim(
					{ p1: pl1, p2: pl2 },
					{}
				);


				//this.ricoDX = ko.computed(function () { return this.p3x() / prico.getSize(); }, this);
				//this.ricoDY = ko.computed(function () { return this.p3y() / prico.getSize(); }, this);
				//let rayRico = new Rico2Dim(this.ricoDX, this.ricoDY);

				//let rayref = new Line2Dim(
				//	{ d: this.rayd, prico: rayRico },
				//	{}
				//);


				let func = new Function2Dim({ func: generateRandomCurve() }, { });

				this.funcsToShow = [func];
				this.pointsToShow = [pl1, pl2/*, pampl*/];
				this.raysToShow = [ray/*, rayref*/];
			}

			let vmfunc = new ViewModel();

			space2dimvsum.appenGlobalAttributes(Vector2Dim.global);
			space2dimvsum.registerHandler(Line2Dim.draw, Line2Dim.update, function () { return vmfunc.raysToShow; });
			space2dimvsum.registerHandler(Function2Dim.draw, Function2Dim.update, function () { return vmfunc.funcsToShow; });
			space2dimvsum.registerHandler(Point2Dim.draw, Point2Dim.update, function () { return vmfunc.pointsToShow; });
			space2dimvsum.show();

			return vmfunc;
		}

		function MainViewModel()
		{
			this.LimitSample = createLimitSample();
			this.ContinuitySample = createContinuitySample();
			this.DerivationSample = createFunctionDerivationAnimationSample();
		}

		let vm = new MainViewModel();

		ko.applyBindings(vm);

	</script>
</body>
</html>